"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("_pages-dir-browser_src_components_ChartComponent_js",{

/***/ "(pages-dir-browser)/./src/components/ChartComponent.js":
/*!******************************************!*\
  !*** ./src/components/ChartComponent.js ***!
  \******************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(pages-dir-browser)/./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(pages-dir-browser)/./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var lightweight_charts__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lightweight-charts */ \"(pages-dir-browser)/./node_modules/lightweight-charts/dist/lightweight-charts.development.mjs\");\n\nvar _s = $RefreshSig$();\n\n\n\n// Add helper function for formatting price values consistently\nconst formatPrice = (price, pair)=>{\n    if (price === null || price === undefined) return '';\n    const precision = pair.includes('JPY') ? 3 : 5;\n    return price.toFixed(precision);\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (/*#__PURE__*/_c1 = _s((0,react__WEBPACK_IMPORTED_MODULE_1__.forwardRef)(_c = _s((param, ref)=>{\n    let { pair, timeframe } = param;\n    _s();\n    // First, ensure all references are initialized at the component top level\n    // to avoid \"Cannot access uninitialized variable\" errors\n    // Define refs first - before any functions that might use them\n    const chartContainerRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const chartRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const candlestickSeriesRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const volumeSeriesRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const priceLabelRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const markerSeriesRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const resizeObserverRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const timerRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const updateIntervalRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const isMountedRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(true);\n    const isFetchingRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(false);\n    const chartInitializedRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(false);\n    const isRetryingRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(false);\n    const containerReadyRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(false);\n    const tradesContainerRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    // Define state variables next\n    const [isLoading, setIsLoading] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(true);\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [currentPrice, setCurrentPrice] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [priceChangePositive, setPriceChangePositive] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(true);\n    const [lastUpdateTime, setLastUpdateTime] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [trades, setTrades] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const [isFetchingTrades, setIsFetchingTrades] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    // Define utility functions before they're used\n    const cleanupTimersAndIntervals = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"useCallback[cleanupTimersAndIntervals]\": ()=>{\n            if (timerRef.current) {\n                clearTimeout(timerRef.current);\n                timerRef.current = null;\n            }\n            if (updateIntervalRef.current) {\n                clearInterval(updateIntervalRef.current);\n                updateIntervalRef.current = null;\n            }\n            if (resizeObserverRef.current) {\n                resizeObserverRef.current.disconnect();\n                resizeObserverRef.current = null;\n            }\n        }\n    }[\"useCallback[cleanupTimersAndIntervals]\"], []);\n    const cleanupChart = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"useCallback[cleanupChart]\": ()=>{\n            if (chartRef.current) {\n                try {\n                    chartRef.current.remove();\n                    console.log(\"Chart removed successfully\");\n                } catch (err) {\n                    console.error(\"Error removing chart:\", err);\n                }\n                chartRef.current = null;\n                candlestickSeriesRef.current = null;\n                volumeSeriesRef.current = null;\n                priceLabelRef.current = null;\n            }\n        }\n    }[\"useCallback[cleanupChart]\"], []);\n    // Define fetchCandleData before handleRetry to avoid circular reference\n    const fetchCandleData = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"useCallback[fetchCandleData]\": ()=>{\n            // Skip if already fetching\n            if (isFetchingRef.current || !isMountedRef.current) {\n                console.log(\"Fetch already in progress or component unmounted, skipping\");\n                return Promise.resolve();\n            }\n            // Skip if no chart reference exists\n            if (!chartRef.current || !candlestickSeriesRef.current) {\n                console.log(\"Chart references not available, skipping data fetch\");\n                return Promise.resolve();\n            }\n            console.log(\"Fetching candle data for \".concat(pair, \"/\").concat(timeframe));\n            isFetchingRef.current = true;\n            return fetch(\"/api/candles?pair=\".concat(pair, \"&timeframe=\").concat(timeframe, \"&_=\").concat(Date.now()), {\n                headers: {\n                    'Cache-Control': 'no-cache, no-store',\n                    'Pragma': 'no-cache'\n                }\n            }).then({\n                \"useCallback[fetchCandleData]\": (response)=>{\n                    if (!response.ok) {\n                        throw new Error(\"API error: \".concat(response.status));\n                    }\n                    return response.json();\n                }\n            }[\"useCallback[fetchCandleData]\"]).then({\n                \"useCallback[fetchCandleData]\": (data)=>{\n                    var _data_candles;\n                    // Check if component still mounted and references valid\n                    if (!isMountedRef.current || !chartRef.current || !candlestickSeriesRef.current) {\n                        console.log(\"Component unmounted or references lost during fetch\");\n                        return;\n                    }\n                    console.log(\"Received \".concat(((_data_candles = data.candles) === null || _data_candles === void 0 ? void 0 : _data_candles.length) || 0, \" candles\"));\n                    if (!data.candles || !Array.isArray(data.candles) || data.candles.length === 0) {\n                        throw new Error('No valid candle data received');\n                    }\n                    // Format candle data safely\n                    const candleData = data.candles.filter({\n                        \"useCallback[fetchCandleData].candleData\": (candle)=>candle && typeof candle.time === 'number'\n                    }[\"useCallback[fetchCandleData].candleData\"]).map({\n                        \"useCallback[fetchCandleData].candleData\": (candle)=>({\n                                time: candle.time,\n                                open: Number(candle.o) || 0,\n                                high: Number(candle.h) || 0,\n                                low: Number(candle.l) || 0,\n                                close: Number(candle.c) || 0\n                            })\n                    }[\"useCallback[fetchCandleData].candleData\"]);\n                    if (candleData.length === 0) {\n                        throw new Error('No valid candles after filtering');\n                    }\n                    // Set the data\n                    candlestickSeriesRef.current.setData(candleData);\n                    // Update price if available\n                    if (data.currentPrice !== undefined) {\n                        const numericPrice = Number(data.currentPrice);\n                        if (!isNaN(numericPrice)) {\n                            // Determine price direction\n                            if (currentPrice !== null) {\n                                setPriceChangePositive(numericPrice >= currentPrice);\n                            }\n                            setCurrentPrice(numericPrice);\n                            // Update price line if it exists\n                            if (priceLabelRef.current) {\n                                try {\n                                    priceLabelRef.current.applyOptions({\n                                        price: numericPrice,\n                                        title: \"Live: \".concat(formatPrice(numericPrice, pair))\n                                    });\n                                } catch (err) {\n                                    console.error(\"Error updating price line:\", err);\n                                }\n                            }\n                        }\n                    }\n                    // Fit content\n                    try {\n                        chartRef.current.timeScale().fitContent();\n                    } catch (err) {\n                        console.error(\"Error fitting chart content:\", err);\n                    }\n                    // Update last update time\n                    setLastUpdateTime(new Date());\n                    setIsLoading(false);\n                    setError(null);\n                    // Ensure chart is showing appropriate price range\n                    try {\n                        // Adjust the visible range to ensure we see enough price levels\n                        const visibleRange = chartRef.current.timeScale().getVisibleRange();\n                        if (visibleRange) {\n                            const priceScale = chartRef.current.priceScale('right');\n                            if (priceScale) {\n                                // Force price scale update\n                                priceScale.applyOptions({\n                                    autoScale: true,\n                                    mode: 0,\n                                    ticksVisible: true,\n                                    scaleMargins: {\n                                        top: 0.1,\n                                        bottom: 0.1\n                                    }\n                                });\n                            }\n                        }\n                        // Fit content with animation\n                        chartRef.current.timeScale().fitContent();\n                    } catch (err) {\n                        console.error(\"Error adjusting price scale:\", err);\n                    }\n                    return data;\n                }\n            }[\"useCallback[fetchCandleData]\"]).catch({\n                \"useCallback[fetchCandleData]\": (error)=>{\n                    console.error('Error fetching candle data:', error);\n                    if (isMountedRef.current) {\n                        setError(\"Failed to load data: \".concat(error.message));\n                        setIsLoading(false);\n                    }\n                    return null;\n                }\n            }[\"useCallback[fetchCandleData]\"]).finally({\n                \"useCallback[fetchCandleData]\": ()=>{\n                    isFetchingRef.current = false;\n                }\n            }[\"useCallback[fetchCandleData]\"]);\n        }\n    }[\"useCallback[fetchCandleData]\"], [\n        pair,\n        timeframe,\n        currentPrice\n    ]);\n    // Define fetchTrades function to get trade data\n    const fetchTrades = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"useCallback[fetchTrades]\": ()=>{\n            if (isFetchingTrades || !isMountedRef.current) {\n                console.log(\"Trades fetch already in progress or component unmounted, skipping\");\n                return Promise.resolve();\n            }\n            console.log(\"Fetching trades for \".concat(pair, \"/\").concat(timeframe));\n            setIsFetchingTrades(true);\n            return fetch(\"/api/trades?pair=\".concat(pair, \"&timeframe=\").concat(timeframe, \"&_=\").concat(Date.now()), {\n                headers: {\n                    'Cache-Control': 'no-cache, no-store',\n                    'Pragma': 'no-cache'\n                }\n            }).then({\n                \"useCallback[fetchTrades]\": (response)=>{\n                    if (!response.ok) {\n                        throw new Error(\"API error: \".concat(response.status));\n                    }\n                    return response.json();\n                }\n            }[\"useCallback[fetchTrades]\"]).then({\n                \"useCallback[fetchTrades]\": (data)=>{\n                    var _data_trades;\n                    if (!isMountedRef.current) {\n                        console.log(\"Component unmounted during trades fetch\");\n                        return;\n                    }\n                    console.log(\"Received \".concat(((_data_trades = data.trades) === null || _data_trades === void 0 ? void 0 : _data_trades.length) || 0, \" trades\"));\n                    if (!data.trades || !Array.isArray(data.trades)) {\n                        throw new Error('No valid trade data received');\n                    }\n                    setTrades(data.trades);\n                    // Update markers on chart if chart is initialized\n                    if (chartRef.current && candlestickSeriesRef.current) {\n                        updateTradeMarkers(data.trades);\n                    }\n                    return data.trades;\n                }\n            }[\"useCallback[fetchTrades]\"]).catch({\n                \"useCallback[fetchTrades]\": (error)=>{\n                    console.error('Error fetching trade data:', error);\n                    return [];\n                }\n            }[\"useCallback[fetchTrades]\"]).finally({\n                \"useCallback[fetchTrades]\": ()=>{\n                    setIsFetchingTrades(false);\n                }\n            }[\"useCallback[fetchTrades]\"]);\n        }\n    }[\"useCallback[fetchTrades]\"], [\n        pair,\n        timeframe\n    ]);\n    // Function to update trade markers on the chart\n    const updateTradeMarkers = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"useCallback[updateTradeMarkers]\": (tradeData)=>{\n            if (!chartRef.current || !candlestickSeriesRef.current) return;\n            try {\n                // Create markers for entry/exit points\n                const markers = tradeData.flatMap({\n                    \"useCallback[updateTradeMarkers].markers\": (trade)=>{\n                        const time = new Date(trade.timestamp).getTime() / 1000;\n                        const markers = [];\n                        // Entry marker\n                        markers.push({\n                            time,\n                            position: trade.direction === 'buy' ? 'belowBar' : 'aboveBar',\n                            color: trade.direction === 'buy' ? '#10b981' : '#ef4444',\n                            shape: trade.direction === 'buy' ? 'arrowUp' : 'arrowDown',\n                            text: \"Entry \".concat(formatPrice(trade.entry, pair)),\n                            size: 1\n                        });\n                        // Exit marker (for closed trades)\n                        if (trade.status !== 'open') {\n                            markers.push({\n                                time: time + 60 * 60,\n                                position: trade.direction === 'buy' ? 'aboveBar' : 'belowBar',\n                                color: trade.status === 'win' ? '#10b981' : '#ef4444',\n                                shape: 'circle',\n                                text: \"Exit (\".concat(trade.status.toUpperCase(), \")\"),\n                                size: 1\n                            });\n                        }\n                        return markers;\n                    }\n                }[\"useCallback[updateTradeMarkers].markers\"]);\n                // Set markers to the series\n                if (!markerSeriesRef.current) {\n                    // If marker series doesn't exist, use candlestick series for markers\n                    candlestickSeriesRef.current.setMarkers(markers);\n                } else {\n                    markerSeriesRef.current.setMarkers(markers);\n                }\n            } catch (err) {\n                console.error(\"Error updating trade markers:\", err);\n            }\n        }\n    }[\"useCallback[updateTradeMarkers]\"], [\n        pair\n    ]);\n    // Now define handleRetry after fetchCandleData is defined\n    const handleRetry = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"useCallback[handleRetry]\": ()=>{\n            console.log(\"Retry button clicked, hard reset\");\n            if (isRetryingRef.current) {\n                console.log(\"Already retrying, ignoring duplicate request\");\n                return;\n            }\n            isRetryingRef.current = true;\n            setIsLoading(true);\n            setError(null);\n            // Clean up existing resources\n            cleanupChart();\n            cleanupTimersAndIntervals();\n            // Create chart with delay to ensure clean state\n            setTimeout({\n                \"useCallback[handleRetry]\": ()=>{\n                    if (!chartContainerRef.current || !isMountedRef.current) {\n                        setError(\"Chart container not available\");\n                        setIsLoading(false);\n                        isRetryingRef.current = false;\n                        return;\n                    }\n                    try {\n                        const container = chartContainerRef.current;\n                        // Set container styles\n                        container.style.width = '100%';\n                        container.style.height = '100%';\n                        container.style.position = 'relative';\n                        container.style.display = 'block';\n                        // Get dimensions\n                        const width = Math.max(container.clientWidth || 300, 300);\n                        const height = Math.max(container.clientHeight || 300, 300);\n                        console.log(\"Creating chart with dimensions: \".concat(width, \"x\").concat(height));\n                        // Create chart with minimal options\n                        const chart = (0,lightweight_charts__WEBPACK_IMPORTED_MODULE_2__.createChart)(container, {\n                            width,\n                            height,\n                            layout: {\n                                background: {\n                                    color: '#121212'\n                                },\n                                textColor: '#d1d4dc',\n                                fontSize: 12\n                            },\n                            grid: {\n                                vertLines: {\n                                    color: 'rgba(42, 46, 57, 0.4)',\n                                    style: 1\n                                },\n                                horzLines: {\n                                    color: 'rgba(42, 46, 57, 0.4)',\n                                    style: 1\n                                }\n                            },\n                            rightPriceScale: {\n                                borderColor: 'rgba(197, 203, 206, 0.3)',\n                                borderVisible: true,\n                                scaleMargins: {\n                                    top: 0.1,\n                                    bottom: 0.1\n                                },\n                                // Ensure more price labels on the y-axis\n                                minimumHeight: 20,\n                                textColor: '#d1d4dc',\n                                fontSize: 11,\n                                alignLabels: true,\n                                mode: 0,\n                                autoScale: true,\n                                entireTextOnly: false,\n                                ticksVisible: true,\n                                visible: true\n                            },\n                            timeScale: {\n                                borderColor: 'rgba(197, 203, 206, 0.3)',\n                                timeVisible: true,\n                                secondsVisible: false,\n                                tickMarkFormatter: {\n                                    \"useCallback[handleRetry].chart\": (time, tickMarkType, locale)=>{\n                                        const date = new Date(time * 1000);\n                                        // Format based on timeframe\n                                        if (timeframe === '1d' || timeframe === 'Daily' || timeframe === 'Weekly') {\n                                            return date.toLocaleDateString('en-US', {\n                                                month: 'short',\n                                                day: 'numeric'\n                                            });\n                                        } else {\n                                            const hours = date.getHours().toString().padStart(2, '0');\n                                            const minutes = date.getMinutes().toString().padStart(2, '0');\n                                            return \"\".concat(hours, \":\").concat(minutes);\n                                        }\n                                    }\n                                }[\"useCallback[handleRetry].chart\"]\n                            },\n                            crosshair: {\n                                mode: lightweight_charts__WEBPACK_IMPORTED_MODULE_2__.CrosshairMode.Normal,\n                                vertLine: {\n                                    color: 'rgba(224, 227, 235, 0.4)',\n                                    width: 1,\n                                    style: 1,\n                                    visible: true,\n                                    labelVisible: true\n                                },\n                                horzLine: {\n                                    color: 'rgba(224, 227, 235, 0.4)',\n                                    width: 1,\n                                    style: 1,\n                                    visible: true,\n                                    labelVisible: true\n                                }\n                            },\n                            // Handle watermark\n                            watermark: {\n                                visible: false\n                            }\n                        });\n                        // Function to determine appropriate price precision based on pair and current price level\n                        const determinePricePrecision = {\n                            \"useCallback[handleRetry].determinePricePrecision\": (pair, currentPrice)=>{\n                                if (pair.includes('JPY')) return 3;\n                                // For pairs with very small price movements (like some crypto pairs)\n                                if (currentPrice < 0.01) return 8;\n                                // Default for forex pairs like EUR_USD\n                                return 5;\n                            }\n                        }[\"useCallback[handleRetry].determinePricePrecision\"];\n                        // Get appropriate precision for this pair\n                        const precision = determinePricePrecision(pair, currentPrice || 1.0);\n                        const series = chart.addCandlestickSeries({\n                            upColor: '#10b981',\n                            downColor: '#ef4444',\n                            borderVisible: false,\n                            wickUpColor: '#10b981',\n                            wickDownColor: '#ef4444',\n                            priceFormat: {\n                                type: 'price',\n                                precision: precision,\n                                minMove: Math.pow(10, -precision)\n                            },\n                            // Additional formatting for price labels\n                            lastValueVisible: true,\n                            priceLineVisible: true,\n                            priceLineWidth: 1,\n                            priceLineColor: 'rgba(255, 255, 255, 0.5)',\n                            priceLineStyle: lightweight_charts__WEBPACK_IMPORTED_MODULE_2__.LineStyle.Dotted\n                        });\n                        // After creating the chart, make sure the rightPriceScale is properly configured\n                        chart.applyOptions({\n                            rightPriceScale: {\n                                autoScale: true,\n                                mode: 0,\n                                invertScale: false,\n                                alignLabels: true,\n                                borderVisible: true,\n                                scaleMargins: {\n                                    top: 0.1,\n                                    bottom: 0.1\n                                },\n                                ticksVisible: true,\n                                // Adjust the number of price labels\n                                minimumHeight: 20\n                            }\n                        });\n                        // Force price format update\n                        series.applyOptions({\n                            priceFormat: {\n                                type: 'price',\n                                precision: precision,\n                                minMove: Math.pow(10, -precision)\n                            }\n                        });\n                        // Add volume histogram with proper configuration\n                        try {\n                            const volumeSeries = chart.addHistogramSeries({\n                                priceScaleId: '',\n                                scaleMargins: {\n                                    top: 0.85,\n                                    bottom: 0\n                                },\n                                priceFormat: {\n                                    type: 'volume'\n                                },\n                                color: 'rgba(76, 175, 80, 0.5)'\n                            });\n                            volumeSeriesRef.current = volumeSeries;\n                        } catch (err) {\n                            console.error(\"Failed to add volume series:\", err);\n                        // Continue without volume series\n                        }\n                        // Save references\n                        chartRef.current = chart;\n                        candlestickSeriesRef.current = series;\n                        // Add marker series for trade entry/exit points\n                        try {\n                            const markerSeries = chart.addLineSeries({\n                                lineVisible: false,\n                                lastValueVisible: false,\n                                priceLineVisible: false\n                            });\n                            markerSeriesRef.current = markerSeries;\n                        } catch (err) {\n                            console.error(\"Failed to add marker series:\", err);\n                        // Continue without marker series, will fall back to candlestick series for markers\n                        }\n                        // Add price line\n                        const priceLine = series.createPriceLine({\n                            price: 0,\n                            color: '#2196F3',\n                            lineWidth: 1,\n                            axisLabelVisible: true,\n                            title: 'Live'\n                        });\n                        priceLabelRef.current = priceLine;\n                        // Set up resize handler\n                        const handleResize = {\n                            \"useCallback[handleRetry].handleResize\": ()=>{\n                                if (!chartRef.current || !container) return;\n                                const newWidth = container.clientWidth;\n                                const newHeight = container.clientHeight;\n                                if (newWidth > 0 && newHeight > 0) {\n                                    try {\n                                        chartRef.current.resize(newWidth, newHeight);\n                                    } catch (err) {\n                                        console.error(\"Error resizing chart:\", err);\n                                    }\n                                }\n                            }\n                        }[\"useCallback[handleRetry].handleResize\"];\n                        // Set up resize observer\n                        try {\n                            resizeObserverRef.current = new ResizeObserver(handleResize);\n                            resizeObserverRef.current.observe(container);\n                        } catch (err) {\n                            console.error(\"Error setting up ResizeObserver:\", err);\n                            window.addEventListener('resize', handleResize);\n                        }\n                        // Load data\n                        fetchCandleData().then({\n                            \"useCallback[handleRetry]\": (data)=>{\n                                console.log(\"Initial data loaded successfully\");\n                                // If we have volume data, set up volume series\n                                if (data && data.candles && data.candles.length > 0 && data.candles[0].volume && volumeSeriesRef.current) {\n                                    try {\n                                        const volumeData = data.candles.map({\n                                            \"useCallback[handleRetry].volumeData\": (candle)=>({\n                                                    time: candle.time,\n                                                    value: candle.volume || 0,\n                                                    color: candle.c >= candle.o ? 'rgba(16, 185, 129, 0.5)' // green for up\n                                                     : 'rgba(239, 68, 68, 0.5)' // red for down\n                                                })\n                                        }[\"useCallback[handleRetry].volumeData\"]);\n                                        volumeSeriesRef.current.setData(volumeData);\n                                    } catch (err) {\n                                        console.error(\"Error setting volume data:\", err);\n                                    }\n                                }\n                            }\n                        }[\"useCallback[handleRetry]\"]).catch({\n                            \"useCallback[handleRetry]\": (err)=>{\n                                console.error(\"Failed to load initial data:\", err);\n                            }\n                        }[\"useCallback[handleRetry]\"]).finally({\n                            \"useCallback[handleRetry]\": ()=>{\n                                isRetryingRef.current = false;\n                            }\n                        }[\"useCallback[handleRetry]\"]);\n                    } catch (err) {\n                        console.error(\"Error in chart creation:\", err);\n                        setError(\"Chart creation failed: \".concat(err.message));\n                        setIsLoading(false);\n                        isRetryingRef.current = false;\n                    }\n                }\n            }[\"useCallback[handleRetry]\"], 300);\n        }\n    }[\"useCallback[handleRetry]\"], [\n        pair,\n        timeframe,\n        cleanupChart,\n        cleanupTimersAndIntervals,\n        fetchCandleData,\n        currentPrice\n    ]);\n    // Initialize chart only once\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"useEffect\": ()=>{\n            console.log(\"Chart initialization effect running\");\n            // Call handleRetry to initialize the chart\n            handleRetry();\n            // Clean up on unmount\n            return ({\n                \"useEffect\": ()=>{\n                    isMountedRef.current = false;\n                    cleanupChart();\n                    cleanupTimersAndIntervals();\n                }\n            })[\"useEffect\"];\n        }\n    }[\"useEffect\"], []); // Empty dependency array - run only once\n    // Set up data refresh interval\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"useEffect\": ()=>{\n            if (!chartRef.current || !candlestickSeriesRef.current) return;\n            console.log(\"Setting up data refresh interval\");\n            // Update every 30 seconds\n            updateIntervalRef.current = setInterval({\n                \"useEffect\": ()=>{\n                    if (isMountedRef.current && !isFetchingRef.current) {\n                        fetchCandleData().catch({\n                            \"useEffect\": (err)=>{\n                                console.error(\"Error in interval fetch:\", err);\n                            }\n                        }[\"useEffect\"]);\n                    }\n                }\n            }[\"useEffect\"], 30000);\n            return ({\n                \"useEffect\": ()=>{\n                    if (updateIntervalRef.current) {\n                        clearInterval(updateIntervalRef.current);\n                        updateIntervalRef.current = null;\n                    }\n                }\n            })[\"useEffect\"];\n        }\n    }[\"useEffect\"], [\n        fetchCandleData\n    ]);\n    // Set up trade data fetch\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"useEffect\": ()=>{\n            if (!chartRef.current || !candlestickSeriesRef.current) return;\n            console.log(\"Fetching initial trade data\");\n            fetchTrades().catch({\n                \"useEffect\": (err)=>{\n                    console.error(\"Error fetching initial trade data:\", err);\n                }\n            }[\"useEffect\"]);\n            // Set up interval to refresh trade data\n            const tradeUpdateInterval = setInterval({\n                \"useEffect.tradeUpdateInterval\": ()=>{\n                    if (isMountedRef.current && !isFetchingTrades) {\n                        fetchTrades().catch({\n                            \"useEffect.tradeUpdateInterval\": (err)=>{\n                                console.error(\"Error in trade interval fetch:\", err);\n                            }\n                        }[\"useEffect.tradeUpdateInterval\"]);\n                    }\n                }\n            }[\"useEffect.tradeUpdateInterval\"], 30000);\n            return ({\n                \"useEffect\": ()=>{\n                    clearInterval(tradeUpdateInterval);\n                }\n            })[\"useEffect\"];\n        }\n    }[\"useEffect\"], [\n        fetchTrades\n    ]);\n    // Use useLayoutEffect to check container dimensions before mounting\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useLayoutEffect)({\n        \"useLayoutEffect\": ()=>{\n            if (chartContainerRef.current) {\n                const container = chartContainerRef.current;\n                // Force container to be visible and have dimensions\n                container.style.width = '100%';\n                container.style.height = '100%';\n                container.style.minHeight = '400px';\n                container.style.display = 'block';\n                container.style.position = 'relative';\n                // Log dimensions\n                console.log(\"Initial container dimensions: \".concat(container.clientWidth, \"x\").concat(container.clientHeight));\n                // Set container ready if dimensions are valid\n                if (container.clientWidth > 0 && container.clientHeight > 0) {\n                    containerReadyRef.current = true;\n                } else {\n                    // Force dimensions one more time\n                    container.style.width = '100vw';\n                    container.style.height = '70vh';\n                    // Check again after a moment\n                    setTimeout({\n                        \"useLayoutEffect\": ()=>{\n                            console.log(\"Delayed container dimensions: \".concat(container.clientWidth, \"x\").concat(container.clientHeight));\n                            containerReadyRef.current = container.clientWidth > 0 && container.clientHeight > 0;\n                        }\n                    }[\"useLayoutEffect\"], 100);\n                }\n            }\n        }\n    }[\"useLayoutEffect\"], []);\n    // Initialize chart when component mounts\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"useEffect\": ()=>{\n            console.log(\"ChartComponent mounted\");\n            isMountedRef.current = true;\n            // Wait for next tick to ensure container is in DOM\n            setTimeout({\n                \"useEffect\": ()=>{\n                    if (!containerReadyRef.current && chartContainerRef.current) {\n                        // Check dimensions again\n                        const container = chartContainerRef.current;\n                        console.log(\"Container dimensions before init: \".concat(container.clientWidth, \"x\").concat(container.clientHeight));\n                        // Force minimum size if needed\n                        if (container.clientWidth < 10 || container.clientHeight < 10) {\n                            container.style.width = '100%';\n                            container.style.height = '400px';\n                            container.style.minHeight = '400px';\n                        }\n                    }\n                    const success = handleRetry();\n                    if (success) {\n                        fetchCandleData().then({\n                            \"useEffect\": ()=>{\n                                console.log(\"Initial data loaded successfully\");\n                            }\n                        }[\"useEffect\"]).catch({\n                            \"useEffect\": (err)=>{\n                                console.error(\"Failed to load initial data:\", err);\n                            }\n                        }[\"useEffect\"]);\n                        // Set up data refresh interval\n                        updateIntervalRef.current = setInterval({\n                            \"useEffect\": ()=>{\n                                if (isMountedRef.current && !isFetchingRef.current) {\n                                    fetchCandleData().catch({\n                                        \"useEffect\": (err)=>{\n                                            console.error(\"Error in interval fetch:\", err);\n                                        }\n                                    }[\"useEffect\"]);\n                                }\n                            }\n                        }[\"useEffect\"], 30000);\n                    }\n                }\n            }[\"useEffect\"], 300);\n            return ({\n                \"useEffect\": ()=>{\n                    console.log(\"ChartComponent unmounting\");\n                    isMountedRef.current = false;\n                    cleanupChart();\n                    cleanupTimersAndIntervals();\n                }\n            })[\"useEffect\"];\n        }\n    }[\"useEffect\"], [\n        handleRetry,\n        fetchCandleData,\n        cleanupChart,\n        cleanupTimersAndIntervals\n    ]);\n    // Return component JSX\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"flex flex-col w-full h-full relative\",\n        style: {\n            minHeight: '400px'\n        },\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                ref: chartContainerRef,\n                className: \"flex-1 w-full h-full\",\n                style: {\n                    minHeight: '400px',\n                    width: '100%',\n                    height: '100%',\n                    position: 'relative',\n                    display: 'block'\n                }\n            }, void 0, false, {\n                fileName: \"/Users/emraan.adem/Documents/Projects/Nervala/Nervala.files/src/components/ChartComponent.js\",\n                lineNumber: 744,\n                columnNumber: 7\n            }, undefined),\n            isLoading && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"absolute inset-0 flex items-center justify-center bg-opacity-75 bg-gray-900 z-10\",\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: \"text-white\",\n                    children: \"Loading chart data...\"\n                }, void 0, false, {\n                    fileName: \"/Users/emraan.adem/Documents/Projects/Nervala/Nervala.files/src/components/ChartComponent.js\",\n                    lineNumber: 758,\n                    columnNumber: 11\n                }, undefined)\n            }, void 0, false, {\n                fileName: \"/Users/emraan.adem/Documents/Projects/Nervala/Nervala.files/src/components/ChartComponent.js\",\n                lineNumber: 757,\n                columnNumber: 9\n            }, undefined),\n            error && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"absolute inset-0 flex flex-col items-center justify-center bg-opacity-75 bg-gray-900 z-10\",\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"text-red-500 mb-4\",\n                        children: error\n                    }, void 0, false, {\n                        fileName: \"/Users/emraan.adem/Documents/Projects/Nervala/Nervala.files/src/components/ChartComponent.js\",\n                        lineNumber: 764,\n                        columnNumber: 11\n                    }, undefined),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                        className: \"px-4 py-2 bg-blue-600 hover:bg-blue-700 text-white rounded\",\n                        onClick: handleRetry,\n                        children: \"Retry\"\n                    }, void 0, false, {\n                        fileName: \"/Users/emraan.adem/Documents/Projects/Nervala/Nervala.files/src/components/ChartComponent.js\",\n                        lineNumber: 765,\n                        columnNumber: 11\n                    }, undefined)\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/emraan.adem/Documents/Projects/Nervala/Nervala.files/src/components/ChartComponent.js\",\n                lineNumber: 763,\n                columnNumber: 9\n            }, undefined),\n            currentPrice && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"absolute top-2 right-2 flex items-center space-x-2 z-20\",\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                        className: \"text-sm font-mono \".concat(priceChangePositive ? 'text-green-500' : 'text-red-500'),\n                        children: formatPrice(currentPrice, pair)\n                    }, void 0, false, {\n                        fileName: \"/Users/emraan.adem/Documents/Projects/Nervala/Nervala.files/src/components/ChartComponent.js\",\n                        lineNumber: 776,\n                        columnNumber: 11\n                    }, undefined),\n                    lastUpdateTime && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                        className: \"text-xs text-gray-400\",\n                        children: lastUpdateTime.toLocaleTimeString()\n                    }, void 0, false, {\n                        fileName: \"/Users/emraan.adem/Documents/Projects/Nervala/Nervala.files/src/components/ChartComponent.js\",\n                        lineNumber: 780,\n                        columnNumber: 13\n                    }, undefined)\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/emraan.adem/Documents/Projects/Nervala/Nervala.files/src/components/ChartComponent.js\",\n                lineNumber: 775,\n                columnNumber: 9\n            }, undefined)\n        ]\n    }, void 0, true, {\n        fileName: \"/Users/emraan.adem/Documents/Projects/Nervala/Nervala.files/src/components/ChartComponent.js\",\n        lineNumber: 743,\n        columnNumber: 5\n    }, undefined);\n}, \"mq8wYmtIUWHV+6OE3LEiaoeOLX0=\")), \"mq8wYmtIUWHV+6OE3LEiaoeOLX0=\"));\nvar _c, _c1;\n$RefreshReg$(_c, \"%default%$forwardRef\");\n$RefreshReg$(_c1, \"%default%\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL0NoYXJ0Q29tcG9uZW50LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQW1IO0FBQ3hDO0FBQ0w7QUFFdEUsK0RBQStEO0FBQy9ELE1BQU1lLGNBQWMsQ0FBQ0MsT0FBT0M7SUFDMUIsSUFBSUQsVUFBVSxRQUFRQSxVQUFVRSxXQUFXLE9BQU87SUFDbEQsTUFBTUMsWUFBWUYsS0FBS0csUUFBUSxDQUFDLFNBQVMsSUFBSTtJQUM3QyxPQUFPSixNQUFNSyxPQUFPLENBQUNGO0FBQ3ZCO0FBRUEsb0ZBQWVkLEdBQUFBLGlEQUFVQSxTQUFDLFFBQXNCaUI7UUFBckIsRUFBRUwsSUFBSSxFQUFFTSxTQUFTLEVBQUU7O0lBQzVDLDBFQUEwRTtJQUMxRSx5REFBeUQ7SUFFekQsK0RBQStEO0lBQy9ELE1BQU1DLG9CQUFvQnZCLDZDQUFNQSxDQUFDO0lBQ2pDLE1BQU13QixXQUFXeEIsNkNBQU1BLENBQUM7SUFDeEIsTUFBTXlCLHVCQUF1QnpCLDZDQUFNQSxDQUFDO0lBQ3BDLE1BQU0wQixrQkFBa0IxQiw2Q0FBTUEsQ0FBQztJQUMvQixNQUFNMkIsZ0JBQWdCM0IsNkNBQU1BLENBQUM7SUFDN0IsTUFBTTRCLGtCQUFrQjVCLDZDQUFNQSxDQUFDO0lBQy9CLE1BQU02QixvQkFBb0I3Qiw2Q0FBTUEsQ0FBQztJQUNqQyxNQUFNOEIsV0FBVzlCLDZDQUFNQSxDQUFDO0lBQ3hCLE1BQU0rQixvQkFBb0IvQiw2Q0FBTUEsQ0FBQztJQUNqQyxNQUFNZ0MsZUFBZWhDLDZDQUFNQSxDQUFDO0lBQzVCLE1BQU1pQyxnQkFBZ0JqQyw2Q0FBTUEsQ0FBQztJQUM3QixNQUFNa0Msc0JBQXNCbEMsNkNBQU1BLENBQUM7SUFDbkMsTUFBTW1DLGdCQUFnQm5DLDZDQUFNQSxDQUFDO0lBQzdCLE1BQU1vQyxvQkFBb0JwQyw2Q0FBTUEsQ0FBQztJQUNqQyxNQUFNcUMscUJBQXFCckMsNkNBQU1BLENBQUM7SUFFbEMsOEJB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L05lcnZhbGEuZmlsZXMvc3JjL2NvbXBvbmVudHMvQ2hhcnRDb21wb25lbnQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdXNlRWZmZWN0LCB1c2VSZWYsIHVzZVN0YXRlLCB1c2VDYWxsYmFjaywgdXNlSW1wZXJhdGl2ZUhhbmRsZSwgZm9yd2FyZFJlZiwgdXNlTGF5b3V0RWZmZWN0IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgY3JlYXRlQ2hhcnQsIENyb3NzaGFpck1vZGUsIExpbmVTdHlsZSB9IGZyb20gJ2xpZ2h0d2VpZ2h0LWNoYXJ0cyc7XG5pbXBvcnQgeyBBY3Rpdml0eSwgQXJyb3dEb3duLCBBcnJvd1VwLCBYLCBDbG9jayB9IGZyb20gJ2x1Y2lkZS1yZWFjdCc7XG5cbi8vIEFkZCBoZWxwZXIgZnVuY3Rpb24gZm9yIGZvcm1hdHRpbmcgcHJpY2UgdmFsdWVzIGNvbnNpc3RlbnRseVxuY29uc3QgZm9ybWF0UHJpY2UgPSAocHJpY2UsIHBhaXIpID0+IHtcbiAgaWYgKHByaWNlID09PSBudWxsIHx8IHByaWNlID09PSB1bmRlZmluZWQpIHJldHVybiAnJztcbiAgY29uc3QgcHJlY2lzaW9uID0gcGFpci5pbmNsdWRlcygnSlBZJykgPyAzIDogNTtcbiAgcmV0dXJuIHByaWNlLnRvRml4ZWQocHJlY2lzaW9uKTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGZvcndhcmRSZWYoKHsgcGFpciwgdGltZWZyYW1lIH0sIHJlZikgPT4ge1xuICAvLyBGaXJzdCwgZW5zdXJlIGFsbCByZWZlcmVuY2VzIGFyZSBpbml0aWFsaXplZCBhdCB0aGUgY29tcG9uZW50IHRvcCBsZXZlbFxuICAvLyB0byBhdm9pZCBcIkNhbm5vdCBhY2Nlc3MgdW5pbml0aWFsaXplZCB2YXJpYWJsZVwiIGVycm9yc1xuXG4gIC8vIERlZmluZSByZWZzIGZpcnN0IC0gYmVmb3JlIGFueSBmdW5jdGlvbnMgdGhhdCBtaWdodCB1c2UgdGhlbVxuICBjb25zdCBjaGFydENvbnRhaW5lclJlZiA9IHVzZVJlZihudWxsKTtcbiAgY29uc3QgY2hhcnRSZWYgPSB1c2VSZWYobnVsbCk7XG4gIGNvbnN0IGNhbmRsZXN0aWNrU2VyaWVzUmVmID0gdXNlUmVmKG51bGwpO1xuICBjb25zdCB2b2x1bWVTZXJpZXNSZWYgPSB1c2VSZWYobnVsbCk7XG4gIGNvbnN0IHByaWNlTGFiZWxSZWYgPSB1c2VSZWYobnVsbCk7XG4gIGNvbnN0IG1hcmtlclNlcmllc1JlZiA9IHVzZVJlZihudWxsKTtcbiAgY29uc3QgcmVzaXplT2JzZXJ2ZXJSZWYgPSB1c2VSZWYobnVsbCk7XG4gIGNvbnN0IHRpbWVyUmVmID0gdXNlUmVmKG51bGwpO1xuICBjb25zdCB1cGRhdGVJbnRlcnZhbFJlZiA9IHVzZVJlZihudWxsKTtcbiAgY29uc3QgaXNNb3VudGVkUmVmID0gdXNlUmVmKHRydWUpO1xuICBjb25zdCBpc0ZldGNoaW5nUmVmID0gdXNlUmVmKGZhbHNlKTtcbiAgY29uc3QgY2hhcnRJbml0aWFsaXplZFJlZiA9IHVzZVJlZihmYWxzZSk7XG4gIGNvbnN0IGlzUmV0cnlpbmdSZWYgPSB1c2VSZWYoZmFsc2UpO1xuICBjb25zdCBjb250YWluZXJSZWFkeVJlZiA9IHVzZVJlZihmYWxzZSk7XG4gIGNvbnN0IHRyYWRlc0NvbnRhaW5lclJlZiA9IHVzZVJlZihudWxsKTtcblxuICAvLyBEZWZpbmUgc3RhdGUgdmFyaWFibGVzIG5leHRcbiAgY29uc3QgW2lzTG9hZGluZywgc2V0SXNMb2FkaW5nXSA9IHVzZVN0YXRlKHRydWUpO1xuICBjb25zdCBbZXJyb3IsIHNldEVycm9yXSA9IHVzZVN0YXRlKG51bGwpO1xuICBjb25zdCBbY3VycmVudFByaWNlLCBzZXRDdXJyZW50UHJpY2VdID0gdXNlU3RhdGUobnVsbCk7XG4gIGNvbnN0IFtwcmljZUNoYW5nZVBvc2l0aXZlLCBzZXRQcmljZUNoYW5nZVBvc2l0aXZlXSA9IHVzZVN0YXRlKHRydWUpO1xuICBjb25zdCBbbGFzdFVwZGF0ZVRpbWUsIHNldExhc3RVcGRhdGVUaW1lXSA9IHVzZVN0YXRlKG51bGwpO1xuICBjb25zdCBbdHJhZGVzLCBzZXRUcmFkZXNdID0gdXNlU3RhdGUoW10pO1xuICBjb25zdCBbaXNGZXRjaGluZ1RyYWRlcywgc2V0SXNGZXRjaGluZ1RyYWRlc10gPSB1c2VTdGF0ZShmYWxzZSk7XG5cbiAgLy8gRGVmaW5lIHV0aWxpdHkgZnVuY3Rpb25zIGJlZm9yZSB0aGV5J3JlIHVzZWRcbiAgY29uc3QgY2xlYW51cFRpbWVyc0FuZEludGVydmFscyA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBpZiAodGltZXJSZWYuY3VycmVudCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyUmVmLmN1cnJlbnQpO1xuICAgICAgdGltZXJSZWYuY3VycmVudCA9IG51bGw7XG4gICAgfVxuICAgIFxuICAgIGlmICh1cGRhdGVJbnRlcnZhbFJlZi5jdXJyZW50KSB7XG4gICAgICBjbGVhckludGVydmFsKHVwZGF0ZUludGVydmFsUmVmLmN1cnJlbnQpO1xuICAgICAgdXBkYXRlSW50ZXJ2YWxSZWYuY3VycmVudCA9IG51bGw7XG4gICAgfVxuICAgIFxuICAgIGlmIChyZXNpemVPYnNlcnZlclJlZi5jdXJyZW50KSB7XG4gICAgICByZXNpemVPYnNlcnZlclJlZi5jdXJyZW50LmRpc2Nvbm5lY3QoKTtcbiAgICAgIHJlc2l6ZU9ic2VydmVyUmVmLmN1cnJlbnQgPSBudWxsO1xuICAgIH1cbiAgfSwgW10pO1xuXG4gIGNvbnN0IGNsZWFudXBDaGFydCA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBpZiAoY2hhcnRSZWYuY3VycmVudCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY2hhcnRSZWYuY3VycmVudC5yZW1vdmUoKTtcbiAgICAgICAgY29uc29sZS5sb2coXCJDaGFydCByZW1vdmVkIHN1Y2Nlc3NmdWxseVwiKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgcmVtb3ZpbmcgY2hhcnQ6XCIsIGVycik7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGNoYXJ0UmVmLmN1cnJlbnQgPSBudWxsO1xuICAgICAgY2FuZGxlc3RpY2tTZXJpZXNSZWYuY3VycmVudCA9IG51bGw7XG4gICAgICB2b2x1bWVTZXJpZXNSZWYuY3VycmVudCA9IG51bGw7XG4gICAgICBwcmljZUxhYmVsUmVmLmN1cnJlbnQgPSBudWxsO1xuICAgIH1cbiAgfSwgW10pO1xuXG4gIC8vIERlZmluZSBmZXRjaENhbmRsZURhdGEgYmVmb3JlIGhhbmRsZVJldHJ5IHRvIGF2b2lkIGNpcmN1bGFyIHJlZmVyZW5jZVxuICBjb25zdCBmZXRjaENhbmRsZURhdGEgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgLy8gU2tpcCBpZiBhbHJlYWR5IGZldGNoaW5nXG4gICAgaWYgKGlzRmV0Y2hpbmdSZWYuY3VycmVudCB8fCAhaXNNb3VudGVkUmVmLmN1cnJlbnQpIHtcbiAgICAgIGNvbnNvbGUubG9nKFwiRmV0Y2ggYWxyZWFkeSBpbiBwcm9ncmVzcyBvciBjb21wb25lbnQgdW5tb3VudGVkLCBza2lwcGluZ1wiKTtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9XG4gICAgXG4gICAgLy8gU2tpcCBpZiBubyBjaGFydCByZWZlcmVuY2UgZXhpc3RzXG4gICAgaWYgKCFjaGFydFJlZi5jdXJyZW50IHx8ICFjYW5kbGVzdGlja1Nlcmllc1JlZi5jdXJyZW50KSB7XG4gICAgICBjb25zb2xlLmxvZyhcIkNoYXJ0IHJlZmVyZW5jZXMgbm90IGF2YWlsYWJsZSwgc2tpcHBpbmcgZGF0YSBmZXRjaFwiKTtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9XG4gICAgXG4gICAgY29uc29sZS5sb2coYEZldGNoaW5nIGNhbmRsZSBkYXRhIGZvciAke3BhaXJ9LyR7dGltZWZyYW1lfWApO1xuICAgIGlzRmV0Y2hpbmdSZWYuY3VycmVudCA9IHRydWU7XG4gICAgXG4gICAgcmV0dXJuIGZldGNoKGAvYXBpL2NhbmRsZXM/cGFpcj0ke3BhaXJ9JnRpbWVmcmFtZT0ke3RpbWVmcmFtZX0mXz0ke0RhdGUubm93KCl9YCwge1xuICAgICAgaGVhZGVyczoge1xuICAgICAgICAnQ2FjaGUtQ29udHJvbCc6ICduby1jYWNoZSwgbm8tc3RvcmUnLFxuICAgICAgICAnUHJhZ21hJzogJ25vLWNhY2hlJ1xuICAgICAgfVxuICAgIH0pXG4gICAgICAudGhlbihyZXNwb25zZSA9PiB7XG4gICAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEFQSSBlcnJvcjogJHtyZXNwb25zZS5zdGF0dXN9YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKTtcbiAgICAgIH0pXG4gICAgICAudGhlbihkYXRhID0+IHtcbiAgICAgICAgLy8gQ2hlY2sgaWYgY29tcG9uZW50IHN0aWxsIG1vdW50ZWQgYW5kIHJlZmVyZW5jZXMgdmFsaWRcbiAgICAgICAgaWYgKCFpc01vdW50ZWRSZWYuY3VycmVudCB8fCAhY2hhcnRSZWYuY3VycmVudCB8fCAhY2FuZGxlc3RpY2tTZXJpZXNSZWYuY3VycmVudCkge1xuICAgICAgICAgIGNvbnNvbGUubG9nKFwiQ29tcG9uZW50IHVubW91bnRlZCBvciByZWZlcmVuY2VzIGxvc3QgZHVyaW5nIGZldGNoXCIpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgY29uc29sZS5sb2coYFJlY2VpdmVkICR7ZGF0YS5jYW5kbGVzPy5sZW5ndGggfHwgMH0gY2FuZGxlc2ApO1xuICAgICAgICBcbiAgICAgICAgaWYgKCFkYXRhLmNhbmRsZXMgfHwgIUFycmF5LmlzQXJyYXkoZGF0YS5jYW5kbGVzKSB8fCBkYXRhLmNhbmRsZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyB2YWxpZCBjYW5kbGUgZGF0YSByZWNlaXZlZCcpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBGb3JtYXQgY2FuZGxlIGRhdGEgc2FmZWx5XG4gICAgICAgIGNvbnN0IGNhbmRsZURhdGEgPSBkYXRhLmNhbmRsZXNcbiAgICAgICAgICAuZmlsdGVyKGNhbmRsZSA9PiBjYW5kbGUgJiYgdHlwZW9mIGNhbmRsZS50aW1lID09PSAnbnVtYmVyJylcbiAgICAgICAgICAubWFwKGNhbmRsZSA9PiAoe1xuICAgICAgICAgICAgdGltZTogY2FuZGxlLnRpbWUsXG4gICAgICAgICAgICBvcGVuOiBOdW1iZXIoY2FuZGxlLm8pIHx8IDAsXG4gICAgICAgICAgICBoaWdoOiBOdW1iZXIoY2FuZGxlLmgpIHx8IDAsXG4gICAgICAgICAgICBsb3c6IE51bWJlcihjYW5kbGUubCkgfHwgMCxcbiAgICAgICAgICAgIGNsb3NlOiBOdW1iZXIoY2FuZGxlLmMpIHx8IDBcbiAgICAgICAgICB9KSk7XG4gICAgICAgIFxuICAgICAgICBpZiAoY2FuZGxlRGF0YS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIHZhbGlkIGNhbmRsZXMgYWZ0ZXIgZmlsdGVyaW5nJyk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIFNldCB0aGUgZGF0YVxuICAgICAgICBjYW5kbGVzdGlja1Nlcmllc1JlZi5jdXJyZW50LnNldERhdGEoY2FuZGxlRGF0YSk7XG4gICAgICAgIFxuICAgICAgICAvLyBVcGRhdGUgcHJpY2UgaWYgYXZhaWxhYmxlXG4gICAgICAgIGlmIChkYXRhLmN1cnJlbnRQcmljZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgY29uc3QgbnVtZXJpY1ByaWNlID0gTnVtYmVyKGRhdGEuY3VycmVudFByaWNlKTtcbiAgICAgICAgICBpZiAoIWlzTmFOKG51bWVyaWNQcmljZSkpIHtcbiAgICAgICAgICAgIC8vIERldGVybWluZSBwcmljZSBkaXJlY3Rpb25cbiAgICAgICAgICAgIGlmIChjdXJyZW50UHJpY2UgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgc2V0UHJpY2VDaGFuZ2VQb3NpdGl2ZShudW1lcmljUHJpY2UgPj0gY3VycmVudFByaWNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNldEN1cnJlbnRQcmljZShudW1lcmljUHJpY2UpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBVcGRhdGUgcHJpY2UgbGluZSBpZiBpdCBleGlzdHNcbiAgICAgICAgICAgIGlmIChwcmljZUxhYmVsUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBwcmljZUxhYmVsUmVmLmN1cnJlbnQuYXBwbHlPcHRpb25zKHtcbiAgICAgICAgICAgICAgICAgIHByaWNlOiBudW1lcmljUHJpY2UsXG4gICAgICAgICAgICAgICAgICB0aXRsZTogYExpdmU6ICR7Zm9ybWF0UHJpY2UobnVtZXJpY1ByaWNlLCBwYWlyKX1gLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgdXBkYXRpbmcgcHJpY2UgbGluZTpcIiwgZXJyKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gRml0IGNvbnRlbnRcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjaGFydFJlZi5jdXJyZW50LnRpbWVTY2FsZSgpLmZpdENvbnRlbnQoKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGZpdHRpbmcgY2hhcnQgY29udGVudDpcIiwgZXJyKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gVXBkYXRlIGxhc3QgdXBkYXRlIHRpbWVcbiAgICAgICAgc2V0TGFzdFVwZGF0ZVRpbWUobmV3IERhdGUoKSk7XG4gICAgICAgIHNldElzTG9hZGluZyhmYWxzZSk7XG4gICAgICAgIHNldEVycm9yKG51bGwpO1xuICAgICAgICBcbiAgICAgICAgLy8gRW5zdXJlIGNoYXJ0IGlzIHNob3dpbmcgYXBwcm9wcmlhdGUgcHJpY2UgcmFuZ2VcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBBZGp1c3QgdGhlIHZpc2libGUgcmFuZ2UgdG8gZW5zdXJlIHdlIHNlZSBlbm91Z2ggcHJpY2UgbGV2ZWxzXG4gICAgICAgICAgY29uc3QgdmlzaWJsZVJhbmdlID0gY2hhcnRSZWYuY3VycmVudC50aW1lU2NhbGUoKS5nZXRWaXNpYmxlUmFuZ2UoKTtcbiAgICAgICAgICBpZiAodmlzaWJsZVJhbmdlKSB7XG4gICAgICAgICAgICBjb25zdCBwcmljZVNjYWxlID0gY2hhcnRSZWYuY3VycmVudC5wcmljZVNjYWxlKCdyaWdodCcpO1xuICAgICAgICAgICAgaWYgKHByaWNlU2NhbGUpIHtcbiAgICAgICAgICAgICAgLy8gRm9yY2UgcHJpY2Ugc2NhbGUgdXBkYXRlXG4gICAgICAgICAgICAgIHByaWNlU2NhbGUuYXBwbHlPcHRpb25zKHtcbiAgICAgICAgICAgICAgICBhdXRvU2NhbGU6IHRydWUsXG4gICAgICAgICAgICAgICAgbW9kZTogMCxcbiAgICAgICAgICAgICAgICB0aWNrc1Zpc2libGU6IHRydWUsXG4gICAgICAgICAgICAgICAgc2NhbGVNYXJnaW5zOiB7XG4gICAgICAgICAgICAgICAgICB0b3A6IDAuMSwgXG4gICAgICAgICAgICAgICAgICBib3R0b206IDAuMSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gRml0IGNvbnRlbnQgd2l0aCBhbmltYXRpb25cbiAgICAgICAgICBjaGFydFJlZi5jdXJyZW50LnRpbWVTY2FsZSgpLmZpdENvbnRlbnQoKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGFkanVzdGluZyBwcmljZSBzY2FsZTpcIiwgZXJyKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICB9KVxuICAgICAgLmNhdGNoKGVycm9yID0+IHtcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZmV0Y2hpbmcgY2FuZGxlIGRhdGE6JywgZXJyb3IpO1xuICAgICAgICBpZiAoaXNNb3VudGVkUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICBzZXRFcnJvcihgRmFpbGVkIHRvIGxvYWQgZGF0YTogJHtlcnJvci5tZXNzYWdlfWApO1xuICAgICAgICAgIHNldElzTG9hZGluZyhmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9KVxuICAgICAgLmZpbmFsbHkoKCkgPT4ge1xuICAgICAgICBpc0ZldGNoaW5nUmVmLmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgIH0pO1xuICB9LCBbcGFpciwgdGltZWZyYW1lLCBjdXJyZW50UHJpY2VdKTtcblxuICAvLyBEZWZpbmUgZmV0Y2hUcmFkZXMgZnVuY3Rpb24gdG8gZ2V0IHRyYWRlIGRhdGFcbiAgY29uc3QgZmV0Y2hUcmFkZXMgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgaWYgKGlzRmV0Y2hpbmdUcmFkZXMgfHwgIWlzTW91bnRlZFJlZi5jdXJyZW50KSB7XG4gICAgICBjb25zb2xlLmxvZyhcIlRyYWRlcyBmZXRjaCBhbHJlYWR5IGluIHByb2dyZXNzIG9yIGNvbXBvbmVudCB1bm1vdW50ZWQsIHNraXBwaW5nXCIpO1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH1cbiAgICBcbiAgICBjb25zb2xlLmxvZyhgRmV0Y2hpbmcgdHJhZGVzIGZvciAke3BhaXJ9LyR7dGltZWZyYW1lfWApO1xuICAgIHNldElzRmV0Y2hpbmdUcmFkZXModHJ1ZSk7XG4gICAgXG4gICAgcmV0dXJuIGZldGNoKGAvYXBpL3RyYWRlcz9wYWlyPSR7cGFpcn0mdGltZWZyYW1lPSR7dGltZWZyYW1lfSZfPSR7RGF0ZS5ub3coKX1gLCB7XG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgICdDYWNoZS1Db250cm9sJzogJ25vLWNhY2hlLCBuby1zdG9yZScsXG4gICAgICAgICdQcmFnbWEnOiAnbm8tY2FjaGUnXG4gICAgICB9XG4gICAgfSlcbiAgICAgIC50aGVuKHJlc3BvbnNlID0+IHtcbiAgICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQVBJIGVycm9yOiAke3Jlc3BvbnNlLnN0YXR1c31gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpO1xuICAgICAgfSlcbiAgICAgIC50aGVuKGRhdGEgPT4ge1xuICAgICAgICBpZiAoIWlzTW91bnRlZFJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgY29uc29sZS5sb2coXCJDb21wb25lbnQgdW5tb3VudGVkIGR1cmluZyB0cmFkZXMgZmV0Y2hcIik7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBjb25zb2xlLmxvZyhgUmVjZWl2ZWQgJHtkYXRhLnRyYWRlcz8ubGVuZ3RoIHx8IDB9IHRyYWRlc2ApO1xuICAgICAgICBcbiAgICAgICAgaWYgKCFkYXRhLnRyYWRlcyB8fCAhQXJyYXkuaXNBcnJheShkYXRhLnRyYWRlcykpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIHZhbGlkIHRyYWRlIGRhdGEgcmVjZWl2ZWQnKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgc2V0VHJhZGVzKGRhdGEudHJhZGVzKTtcbiAgICAgICAgXG4gICAgICAgIC8vIFVwZGF0ZSBtYXJrZXJzIG9uIGNoYXJ0IGlmIGNoYXJ0IGlzIGluaXRpYWxpemVkXG4gICAgICAgIGlmIChjaGFydFJlZi5jdXJyZW50ICYmIGNhbmRsZXN0aWNrU2VyaWVzUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICB1cGRhdGVUcmFkZU1hcmtlcnMoZGF0YS50cmFkZXMpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gZGF0YS50cmFkZXM7XG4gICAgICB9KVxuICAgICAgLmNhdGNoKGVycm9yID0+IHtcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZmV0Y2hpbmcgdHJhZGUgZGF0YTonLCBlcnJvcik7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH0pXG4gICAgICAuZmluYWxseSgoKSA9PiB7XG4gICAgICAgIHNldElzRmV0Y2hpbmdUcmFkZXMoZmFsc2UpO1xuICAgICAgfSk7XG4gIH0sIFtwYWlyLCB0aW1lZnJhbWVdKTtcbiAgXG4gIC8vIEZ1bmN0aW9uIHRvIHVwZGF0ZSB0cmFkZSBtYXJrZXJzIG9uIHRoZSBjaGFydFxuICBjb25zdCB1cGRhdGVUcmFkZU1hcmtlcnMgPSB1c2VDYWxsYmFjaygodHJhZGVEYXRhKSA9PiB7XG4gICAgaWYgKCFjaGFydFJlZi5jdXJyZW50IHx8ICFjYW5kbGVzdGlja1Nlcmllc1JlZi5jdXJyZW50KSByZXR1cm47XG4gICAgXG4gICAgdHJ5IHtcbiAgICAgIC8vIENyZWF0ZSBtYXJrZXJzIGZvciBlbnRyeS9leGl0IHBvaW50c1xuICAgICAgY29uc3QgbWFya2VycyA9IHRyYWRlRGF0YS5mbGF0TWFwKHRyYWRlID0+IHtcbiAgICAgICAgY29uc3QgdGltZSA9IG5ldyBEYXRlKHRyYWRlLnRpbWVzdGFtcCkuZ2V0VGltZSgpIC8gMTAwMDtcbiAgICAgICAgY29uc3QgbWFya2VycyA9IFtdO1xuICAgICAgICBcbiAgICAgICAgLy8gRW50cnkgbWFya2VyXG4gICAgICAgIG1hcmtlcnMucHVzaCh7XG4gICAgICAgICAgdGltZSxcbiAgICAgICAgICBwb3NpdGlvbjogdHJhZGUuZGlyZWN0aW9uID09PSAnYnV5JyA/ICdiZWxvd0JhcicgOiAnYWJvdmVCYXInLFxuICAgICAgICAgIGNvbG9yOiB0cmFkZS5kaXJlY3Rpb24gPT09ICdidXknID8gJyMxMGI5ODEnIDogJyNlZjQ0NDQnLFxuICAgICAgICAgIHNoYXBlOiB0cmFkZS5kaXJlY3Rpb24gPT09ICdidXknID8gJ2Fycm93VXAnIDogJ2Fycm93RG93bicsXG4gICAgICAgICAgdGV4dDogYEVudHJ5ICR7Zm9ybWF0UHJpY2UodHJhZGUuZW50cnksIHBhaXIpfWAsXG4gICAgICAgICAgc2l6ZTogMVxuICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgIC8vIEV4aXQgbWFya2VyIChmb3IgY2xvc2VkIHRyYWRlcylcbiAgICAgICAgaWYgKHRyYWRlLnN0YXR1cyAhPT0gJ29wZW4nKSB7XG4gICAgICAgICAgbWFya2Vycy5wdXNoKHtcbiAgICAgICAgICAgIHRpbWU6IHRpbWUgKyAoNjAgKiA2MCksIC8vIEFkZCBzb21lIHRpbWUgb2Zmc2V0IGZvciB2aXN1YWxpemF0aW9uXG4gICAgICAgICAgICBwb3NpdGlvbjogdHJhZGUuZGlyZWN0aW9uID09PSAnYnV5JyA/ICdhYm92ZUJhcicgOiAnYmVsb3dCYXInLFxuICAgICAgICAgICAgY29sb3I6IHRyYWRlLnN0YXR1cyA9PT0gJ3dpbicgPyAnIzEwYjk4MScgOiAnI2VmNDQ0NCcsXG4gICAgICAgICAgICBzaGFwZTogJ2NpcmNsZScsXG4gICAgICAgICAgICB0ZXh0OiBgRXhpdCAoJHt0cmFkZS5zdGF0dXMudG9VcHBlckNhc2UoKX0pYCxcbiAgICAgICAgICAgIHNpemU6IDFcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgcmV0dXJuIG1hcmtlcnM7XG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgLy8gU2V0IG1hcmtlcnMgdG8gdGhlIHNlcmllc1xuICAgICAgaWYgKCFtYXJrZXJTZXJpZXNSZWYuY3VycmVudCkge1xuICAgICAgICAvLyBJZiBtYXJrZXIgc2VyaWVzIGRvZXNuJ3QgZXhpc3QsIHVzZSBjYW5kbGVzdGljayBzZXJpZXMgZm9yIG1hcmtlcnNcbiAgICAgICAgY2FuZGxlc3RpY2tTZXJpZXNSZWYuY3VycmVudC5zZXRNYXJrZXJzKG1hcmtlcnMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWFya2VyU2VyaWVzUmVmLmN1cnJlbnQuc2V0TWFya2VycyhtYXJrZXJzKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciB1cGRhdGluZyB0cmFkZSBtYXJrZXJzOlwiLCBlcnIpO1xuICAgIH1cbiAgfSwgW3BhaXJdKTtcblxuICAvLyBOb3cgZGVmaW5lIGhhbmRsZVJldHJ5IGFmdGVyIGZldGNoQ2FuZGxlRGF0YSBpcyBkZWZpbmVkXG4gIGNvbnN0IGhhbmRsZVJldHJ5ID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIGNvbnNvbGUubG9nKFwiUmV0cnkgYnV0dG9uIGNsaWNrZWQsIGhhcmQgcmVzZXRcIik7XG4gICAgXG4gICAgaWYgKGlzUmV0cnlpbmdSZWYuY3VycmVudCkge1xuICAgICAgY29uc29sZS5sb2coXCJBbHJlYWR5IHJldHJ5aW5nLCBpZ25vcmluZyBkdXBsaWNhdGUgcmVxdWVzdFwiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgXG4gICAgaXNSZXRyeWluZ1JlZi5jdXJyZW50ID0gdHJ1ZTtcbiAgICBzZXRJc0xvYWRpbmcodHJ1ZSk7XG4gICAgc2V0RXJyb3IobnVsbCk7XG4gICAgXG4gICAgLy8gQ2xlYW4gdXAgZXhpc3RpbmcgcmVzb3VyY2VzXG4gICAgY2xlYW51cENoYXJ0KCk7XG4gICAgY2xlYW51cFRpbWVyc0FuZEludGVydmFscygpO1xuICAgIFxuICAgIC8vIENyZWF0ZSBjaGFydCB3aXRoIGRlbGF5IHRvIGVuc3VyZSBjbGVhbiBzdGF0ZVxuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgaWYgKCFjaGFydENvbnRhaW5lclJlZi5jdXJyZW50IHx8ICFpc01vdW50ZWRSZWYuY3VycmVudCkge1xuICAgICAgICBzZXRFcnJvcihcIkNoYXJ0IGNvbnRhaW5lciBub3QgYXZhaWxhYmxlXCIpO1xuICAgICAgICBzZXRJc0xvYWRpbmcoZmFsc2UpO1xuICAgICAgICBpc1JldHJ5aW5nUmVmLmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgXG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBjb250YWluZXIgPSBjaGFydENvbnRhaW5lclJlZi5jdXJyZW50O1xuICAgICAgICBcbiAgICAgICAgLy8gU2V0IGNvbnRhaW5lciBzdHlsZXNcbiAgICAgICAgY29udGFpbmVyLnN0eWxlLndpZHRoID0gJzEwMCUnO1xuICAgICAgICBjb250YWluZXIuc3R5bGUuaGVpZ2h0ID0gJzEwMCUnO1xuICAgICAgICBjb250YWluZXIuc3R5bGUucG9zaXRpb24gPSAncmVsYXRpdmUnO1xuICAgICAgICBjb250YWluZXIuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gICAgICAgIFxuICAgICAgICAvLyBHZXQgZGltZW5zaW9uc1xuICAgICAgICBjb25zdCB3aWR0aCA9IE1hdGgubWF4KGNvbnRhaW5lci5jbGllbnRXaWR0aCB8fCAzMDAsIDMwMCk7XG4gICAgICAgIGNvbnN0IGhlaWdodCA9IE1hdGgubWF4KGNvbnRhaW5lci5jbGllbnRIZWlnaHQgfHwgMzAwLCAzMDApO1xuICAgICAgICBcbiAgICAgICAgY29uc29sZS5sb2coYENyZWF0aW5nIGNoYXJ0IHdpdGggZGltZW5zaW9uczogJHt3aWR0aH14JHtoZWlnaHR9YCk7XG4gICAgICAgIFxuICAgICAgICAvLyBDcmVhdGUgY2hhcnQgd2l0aCBtaW5pbWFsIG9wdGlvbnNcbiAgICAgICAgY29uc3QgY2hhcnQgPSBjcmVhdGVDaGFydChjb250YWluZXIsIHtcbiAgICAgICAgICB3aWR0aCxcbiAgICAgICAgICBoZWlnaHQsXG4gICAgICAgICAgbGF5b3V0OiB7XG4gICAgICAgICAgICBiYWNrZ3JvdW5kOiB7IGNvbG9yOiAnIzEyMTIxMicgfSxcbiAgICAgICAgICAgIHRleHRDb2xvcjogJyNkMWQ0ZGMnLFxuICAgICAgICAgICAgZm9udFNpemU6IDEyLFxuICAgICAgICAgIH0sXG4gICAgICAgICAgZ3JpZDoge1xuICAgICAgICAgICAgdmVydExpbmVzOiB7XG4gICAgICAgICAgICAgIGNvbG9yOiAncmdiYSg0MiwgNDYsIDU3LCAwLjQpJyxcbiAgICAgICAgICAgICAgc3R5bGU6IDEsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaG9yekxpbmVzOiB7XG4gICAgICAgICAgICAgIGNvbG9yOiAncmdiYSg0MiwgNDYsIDU3LCAwLjQpJyxcbiAgICAgICAgICAgICAgc3R5bGU6IDEsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgIH0sXG4gICAgICAgICAgcmlnaHRQcmljZVNjYWxlOiB7XG4gICAgICAgICAgICBib3JkZXJDb2xvcjogJ3JnYmEoMTk3LCAyMDMsIDIwNiwgMC4zKScsXG4gICAgICAgICAgICBib3JkZXJWaXNpYmxlOiB0cnVlLFxuICAgICAgICAgICAgc2NhbGVNYXJnaW5zOiB7XG4gICAgICAgICAgICAgIHRvcDogMC4xLFxuICAgICAgICAgICAgICBib3R0b206IDAuMSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvLyBFbnN1cmUgbW9yZSBwcmljZSBsYWJlbHMgb24gdGhlIHktYXhpc1xuICAgICAgICAgICAgbWluaW11bUhlaWdodDogMjAsIC8vIEV2ZW4gc21hbGxlciB2YWx1ZSA9IG1vcmUgbGFiZWxzXG4gICAgICAgICAgICB0ZXh0Q29sb3I6ICcjZDFkNGRjJyxcbiAgICAgICAgICAgIGZvbnRTaXplOiAxMSxcbiAgICAgICAgICAgIGFsaWduTGFiZWxzOiB0cnVlLFxuICAgICAgICAgICAgbW9kZTogMCwgLy8gMCA9IE5vcm1hbCBpcyBiZXR0ZXIgZm9yIHN0YW5kYXJkIHByaWNlIGRpc3BsYXlcbiAgICAgICAgICAgIGF1dG9TY2FsZTogdHJ1ZSxcbiAgICAgICAgICAgIGVudGlyZVRleHRPbmx5OiBmYWxzZSxcbiAgICAgICAgICAgIHRpY2tzVmlzaWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZpc2libGU6IHRydWUsXG4gICAgICAgICAgfSxcbiAgICAgICAgICB0aW1lU2NhbGU6IHtcbiAgICAgICAgICAgIGJvcmRlckNvbG9yOiAncmdiYSgxOTcsIDIwMywgMjA2LCAwLjMpJyxcbiAgICAgICAgICAgIHRpbWVWaXNpYmxlOiB0cnVlLFxuICAgICAgICAgICAgc2Vjb25kc1Zpc2libGU6IGZhbHNlLFxuICAgICAgICAgICAgdGlja01hcmtGb3JtYXR0ZXI6ICh0aW1lLCB0aWNrTWFya1R5cGUsIGxvY2FsZSkgPT4ge1xuICAgICAgICAgICAgICBjb25zdCBkYXRlID0gbmV3IERhdGUodGltZSAqIDEwMDApO1xuICAgICAgICAgICAgICAvLyBGb3JtYXQgYmFzZWQgb24gdGltZWZyYW1lXG4gICAgICAgICAgICAgIGlmICh0aW1lZnJhbWUgPT09ICcxZCcgfHwgdGltZWZyYW1lID09PSAnRGFpbHknIHx8IHRpbWVmcmFtZSA9PT0gJ1dlZWtseScpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGF0ZS50b0xvY2FsZURhdGVTdHJpbmcoJ2VuLVVTJywgeyBtb250aDogJ3Nob3J0JywgZGF5OiAnbnVtZXJpYycgfSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaG91cnMgPSBkYXRlLmdldEhvdXJzKCkudG9TdHJpbmcoKS5wYWRTdGFydCgyLCAnMCcpO1xuICAgICAgICAgICAgICAgIGNvbnN0IG1pbnV0ZXMgPSBkYXRlLmdldE1pbnV0ZXMoKS50b1N0cmluZygpLnBhZFN0YXJ0KDIsICcwJyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGAke2hvdXJzfToke21pbnV0ZXN9YDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICB9LFxuICAgICAgICAgIGNyb3NzaGFpcjoge1xuICAgICAgICAgICAgbW9kZTogQ3Jvc3NoYWlyTW9kZS5Ob3JtYWwsXG4gICAgICAgICAgICB2ZXJ0TGluZToge1xuICAgICAgICAgICAgICBjb2xvcjogJ3JnYmEoMjI0LCAyMjcsIDIzNSwgMC40KScsXG4gICAgICAgICAgICAgIHdpZHRoOiAxLFxuICAgICAgICAgICAgICBzdHlsZTogMSxcbiAgICAgICAgICAgICAgdmlzaWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgbGFiZWxWaXNpYmxlOiB0cnVlLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGhvcnpMaW5lOiB7XG4gICAgICAgICAgICAgIGNvbG9yOiAncmdiYSgyMjQsIDIyNywgMjM1LCAwLjQpJyxcbiAgICAgICAgICAgICAgd2lkdGg6IDEsXG4gICAgICAgICAgICAgIHN0eWxlOiAxLFxuICAgICAgICAgICAgICB2aXNpYmxlOiB0cnVlLFxuICAgICAgICAgICAgICBsYWJlbFZpc2libGU6IHRydWUsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgIH0sXG4gICAgICAgICAgLy8gSGFuZGxlIHdhdGVybWFya1xuICAgICAgICAgIHdhdGVybWFyazoge1xuICAgICAgICAgICAgdmlzaWJsZTogZmFsc2UsXG4gICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICAvLyBGdW5jdGlvbiB0byBkZXRlcm1pbmUgYXBwcm9wcmlhdGUgcHJpY2UgcHJlY2lzaW9uIGJhc2VkIG9uIHBhaXIgYW5kIGN1cnJlbnQgcHJpY2UgbGV2ZWxcbiAgICAgICAgY29uc3QgZGV0ZXJtaW5lUHJpY2VQcmVjaXNpb24gPSAocGFpciwgY3VycmVudFByaWNlKSA9PiB7XG4gICAgICAgICAgaWYgKHBhaXIuaW5jbHVkZXMoJ0pQWScpKSByZXR1cm4gMztcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBGb3IgcGFpcnMgd2l0aCB2ZXJ5IHNtYWxsIHByaWNlIG1vdmVtZW50cyAobGlrZSBzb21lIGNyeXB0byBwYWlycylcbiAgICAgICAgICBpZiAoY3VycmVudFByaWNlIDwgMC4wMSkgcmV0dXJuIDg7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gRGVmYXVsdCBmb3IgZm9yZXggcGFpcnMgbGlrZSBFVVJfVVNEXG4gICAgICAgICAgcmV0dXJuIDU7XG4gICAgICAgIH07XG4gICAgICAgIFxuICAgICAgICAvLyBHZXQgYXBwcm9wcmlhdGUgcHJlY2lzaW9uIGZvciB0aGlzIHBhaXJcbiAgICAgICAgY29uc3QgcHJlY2lzaW9uID0gZGV0ZXJtaW5lUHJpY2VQcmVjaXNpb24ocGFpciwgY3VycmVudFByaWNlIHx8IDEuMCk7XG4gICAgICAgIFxuICAgICAgICBjb25zdCBzZXJpZXMgPSBjaGFydC5hZGRDYW5kbGVzdGlja1Nlcmllcyh7XG4gICAgICAgICAgdXBDb2xvcjogJyMxMGI5ODEnLCBcbiAgICAgICAgICBkb3duQ29sb3I6ICcjZWY0NDQ0JyxcbiAgICAgICAgICBib3JkZXJWaXNpYmxlOiBmYWxzZSxcbiAgICAgICAgICB3aWNrVXBDb2xvcjogJyMxMGI5ODEnLFxuICAgICAgICAgIHdpY2tEb3duQ29sb3I6ICcjZWY0NDQ0JyxcbiAgICAgICAgICBwcmljZUZvcm1hdDoge1xuICAgICAgICAgICAgdHlwZTogJ3ByaWNlJyxcbiAgICAgICAgICAgIHByZWNpc2lvbjogcHJlY2lzaW9uLFxuICAgICAgICAgICAgbWluTW92ZTogTWF0aC5wb3coMTAsIC1wcmVjaXNpb24pLCAvLyBEeW5hbWljYWxseSBzZXQgbWluaW11bSBwcmljZSBtb3ZlbWVudFxuICAgICAgICAgIH0sXG4gICAgICAgICAgLy8gQWRkaXRpb25hbCBmb3JtYXR0aW5nIGZvciBwcmljZSBsYWJlbHNcbiAgICAgICAgICBsYXN0VmFsdWVWaXNpYmxlOiB0cnVlLFxuICAgICAgICAgIHByaWNlTGluZVZpc2libGU6IHRydWUsXG4gICAgICAgICAgcHJpY2VMaW5lV2lkdGg6IDEsXG4gICAgICAgICAgcHJpY2VMaW5lQ29sb3I6ICdyZ2JhKDI1NSwgMjU1LCAyNTUsIDAuNSknLFxuICAgICAgICAgIHByaWNlTGluZVN0eWxlOiBMaW5lU3R5bGUuRG90dGVkLFxuICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgIC8vIEFmdGVyIGNyZWF0aW5nIHRoZSBjaGFydCwgbWFrZSBzdXJlIHRoZSByaWdodFByaWNlU2NhbGUgaXMgcHJvcGVybHkgY29uZmlndXJlZFxuICAgICAgICBjaGFydC5hcHBseU9wdGlvbnMoe1xuICAgICAgICAgIHJpZ2h0UHJpY2VTY2FsZToge1xuICAgICAgICAgICAgYXV0b1NjYWxlOiB0cnVlLFxuICAgICAgICAgICAgbW9kZTogMCxcbiAgICAgICAgICAgIGludmVydFNjYWxlOiBmYWxzZSxcbiAgICAgICAgICAgIGFsaWduTGFiZWxzOiB0cnVlLFxuICAgICAgICAgICAgYm9yZGVyVmlzaWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHNjYWxlTWFyZ2luczoge1xuICAgICAgICAgICAgICB0b3A6IDAuMSwgXG4gICAgICAgICAgICAgIGJvdHRvbTogMC4xLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHRpY2tzVmlzaWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIC8vIEFkanVzdCB0aGUgbnVtYmVyIG9mIHByaWNlIGxhYmVsc1xuICAgICAgICAgICAgbWluaW11bUhlaWdodDogMjAsXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgIC8vIEZvcmNlIHByaWNlIGZvcm1hdCB1cGRhdGVcbiAgICAgICAgc2VyaWVzLmFwcGx5T3B0aW9ucyh7XG4gICAgICAgICAgcHJpY2VGb3JtYXQ6IHtcbiAgICAgICAgICAgIHR5cGU6ICdwcmljZScsXG4gICAgICAgICAgICBwcmVjaXNpb246IHByZWNpc2lvbixcbiAgICAgICAgICAgIG1pbk1vdmU6IE1hdGgucG93KDEwLCAtcHJlY2lzaW9uKSxcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgLy8gQWRkIHZvbHVtZSBoaXN0b2dyYW0gd2l0aCBwcm9wZXIgY29uZmlndXJhdGlvblxuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IHZvbHVtZVNlcmllcyA9IGNoYXJ0LmFkZEhpc3RvZ3JhbVNlcmllcyh7XG4gICAgICAgICAgICBwcmljZVNjYWxlSWQ6ICcnLCAvLyBVc2UgZGVmYXVsdCBzY2FsZVxuICAgICAgICAgICAgc2NhbGVNYXJnaW5zOiB7XG4gICAgICAgICAgICAgIHRvcDogMC44NSwgLy8gUG9zaXRpb24gdm9sdW1lIGF0IHRoZSBib3R0b21cbiAgICAgICAgICAgICAgYm90dG9tOiAwLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHByaWNlRm9ybWF0OiB7XG4gICAgICAgICAgICAgIHR5cGU6ICd2b2x1bWUnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNvbG9yOiAncmdiYSg3NiwgMTc1LCA4MCwgMC41KScsXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgXG4gICAgICAgICAgdm9sdW1lU2VyaWVzUmVmLmN1cnJlbnQgPSB2b2x1bWVTZXJpZXM7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJGYWlsZWQgdG8gYWRkIHZvbHVtZSBzZXJpZXM6XCIsIGVycik7XG4gICAgICAgICAgLy8gQ29udGludWUgd2l0aG91dCB2b2x1bWUgc2VyaWVzXG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIFNhdmUgcmVmZXJlbmNlc1xuICAgICAgICBjaGFydFJlZi5jdXJyZW50ID0gY2hhcnQ7XG4gICAgICAgIGNhbmRsZXN0aWNrU2VyaWVzUmVmLmN1cnJlbnQgPSBzZXJpZXM7XG4gICAgICAgIFxuICAgICAgICAvLyBBZGQgbWFya2VyIHNlcmllcyBmb3IgdHJhZGUgZW50cnkvZXhpdCBwb2ludHNcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCBtYXJrZXJTZXJpZXMgPSBjaGFydC5hZGRMaW5lU2VyaWVzKHtcbiAgICAgICAgICAgIGxpbmVWaXNpYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIGxhc3RWYWx1ZVZpc2libGU6IGZhbHNlLFxuICAgICAgICAgICAgcHJpY2VMaW5lVmlzaWJsZTogZmFsc2UsXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgbWFya2VyU2VyaWVzUmVmLmN1cnJlbnQgPSBtYXJrZXJTZXJpZXM7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJGYWlsZWQgdG8gYWRkIG1hcmtlciBzZXJpZXM6XCIsIGVycik7XG4gICAgICAgICAgLy8gQ29udGludWUgd2l0aG91dCBtYXJrZXIgc2VyaWVzLCB3aWxsIGZhbGwgYmFjayB0byBjYW5kbGVzdGljayBzZXJpZXMgZm9yIG1hcmtlcnNcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gQWRkIHByaWNlIGxpbmVcbiAgICAgICAgY29uc3QgcHJpY2VMaW5lID0gc2VyaWVzLmNyZWF0ZVByaWNlTGluZSh7XG4gICAgICAgICAgcHJpY2U6IDAsXG4gICAgICAgICAgY29sb3I6ICcjMjE5NkYzJyxcbiAgICAgICAgICBsaW5lV2lkdGg6IDEsXG4gICAgICAgICAgYXhpc0xhYmVsVmlzaWJsZTogdHJ1ZSxcbiAgICAgICAgICB0aXRsZTogJ0xpdmUnLFxuICAgICAgICB9KTtcbiAgICAgICAgcHJpY2VMYWJlbFJlZi5jdXJyZW50ID0gcHJpY2VMaW5lO1xuICAgICAgICBcbiAgICAgICAgLy8gU2V0IHVwIHJlc2l6ZSBoYW5kbGVyXG4gICAgICAgIGNvbnN0IGhhbmRsZVJlc2l6ZSA9ICgpID0+IHtcbiAgICAgICAgICBpZiAoIWNoYXJ0UmVmLmN1cnJlbnQgfHwgIWNvbnRhaW5lcikgcmV0dXJuO1xuICAgICAgICAgIFxuICAgICAgICAgIGNvbnN0IG5ld1dpZHRoID0gY29udGFpbmVyLmNsaWVudFdpZHRoO1xuICAgICAgICAgIGNvbnN0IG5ld0hlaWdodCA9IGNvbnRhaW5lci5jbGllbnRIZWlnaHQ7XG4gICAgICAgICAgXG4gICAgICAgICAgaWYgKG5ld1dpZHRoID4gMCAmJiBuZXdIZWlnaHQgPiAwKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBjaGFydFJlZi5jdXJyZW50LnJlc2l6ZShuZXdXaWR0aCwgbmV3SGVpZ2h0KTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgcmVzaXppbmcgY2hhcnQ6XCIsIGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBcbiAgICAgICAgLy8gU2V0IHVwIHJlc2l6ZSBvYnNlcnZlclxuICAgICAgICB0cnkge1xuICAgICAgICAgIHJlc2l6ZU9ic2VydmVyUmVmLmN1cnJlbnQgPSBuZXcgUmVzaXplT2JzZXJ2ZXIoaGFuZGxlUmVzaXplKTtcbiAgICAgICAgICByZXNpemVPYnNlcnZlclJlZi5jdXJyZW50Lm9ic2VydmUoY29udGFpbmVyKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIHNldHRpbmcgdXAgUmVzaXplT2JzZXJ2ZXI6XCIsIGVycik7XG4gICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIGhhbmRsZVJlc2l6ZSk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIExvYWQgZGF0YVxuICAgICAgICBmZXRjaENhbmRsZURhdGEoKVxuICAgICAgICAgIC50aGVuKChkYXRhKSA9PiB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIkluaXRpYWwgZGF0YSBsb2FkZWQgc3VjY2Vzc2Z1bGx5XCIpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBJZiB3ZSBoYXZlIHZvbHVtZSBkYXRhLCBzZXQgdXAgdm9sdW1lIHNlcmllc1xuICAgICAgICAgICAgaWYgKGRhdGEgJiYgZGF0YS5jYW5kbGVzICYmIGRhdGEuY2FuZGxlcy5sZW5ndGggPiAwICYmIGRhdGEuY2FuZGxlc1swXS52b2x1bWUgJiYgdm9sdW1lU2VyaWVzUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCB2b2x1bWVEYXRhID0gZGF0YS5jYW5kbGVzLm1hcChjYW5kbGUgPT4gKHtcbiAgICAgICAgICAgICAgICAgIHRpbWU6IGNhbmRsZS50aW1lLFxuICAgICAgICAgICAgICAgICAgdmFsdWU6IGNhbmRsZS52b2x1bWUgfHwgMCxcbiAgICAgICAgICAgICAgICAgIGNvbG9yOiBjYW5kbGUuYyA+PSBjYW5kbGUubyBcbiAgICAgICAgICAgICAgICAgICAgPyAncmdiYSgxNiwgMTg1LCAxMjksIDAuNSknICAvLyBncmVlbiBmb3IgdXBcbiAgICAgICAgICAgICAgICAgICAgOiAncmdiYSgyMzksIDY4LCA2OCwgMC41KScgICAvLyByZWQgZm9yIGRvd25cbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgdm9sdW1lU2VyaWVzUmVmLmN1cnJlbnQuc2V0RGF0YSh2b2x1bWVEYXRhKTtcbiAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIHNldHRpbmcgdm9sdW1lIGRhdGE6XCIsIGVycik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuICAgICAgICAgIC5jYXRjaChlcnIgPT4ge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkZhaWxlZCB0byBsb2FkIGluaXRpYWwgZGF0YTpcIiwgZXJyKTtcbiAgICAgICAgICB9KVxuICAgICAgICAgIC5maW5hbGx5KCgpID0+IHtcbiAgICAgICAgICAgIGlzUmV0cnlpbmdSZWYuY3VycmVudCA9IGZhbHNlO1xuICAgICAgICAgIH0pO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBpbiBjaGFydCBjcmVhdGlvbjpcIiwgZXJyKTtcbiAgICAgICAgc2V0RXJyb3IoYENoYXJ0IGNyZWF0aW9uIGZhaWxlZDogJHtlcnIubWVzc2FnZX1gKTtcbiAgICAgICAgc2V0SXNMb2FkaW5nKGZhbHNlKTtcbiAgICAgICAgaXNSZXRyeWluZ1JlZi5jdXJyZW50ID0gZmFsc2U7XG4gICAgICB9XG4gICAgfSwgMzAwKTtcbiAgfSwgW3BhaXIsIHRpbWVmcmFtZSwgY2xlYW51cENoYXJ0LCBjbGVhbnVwVGltZXJzQW5kSW50ZXJ2YWxzLCBmZXRjaENhbmRsZURhdGEsIGN1cnJlbnRQcmljZV0pO1xuXG4gIC8vIEluaXRpYWxpemUgY2hhcnQgb25seSBvbmNlXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc29sZS5sb2coXCJDaGFydCBpbml0aWFsaXphdGlvbiBlZmZlY3QgcnVubmluZ1wiKTtcbiAgICBcbiAgICAvLyBDYWxsIGhhbmRsZVJldHJ5IHRvIGluaXRpYWxpemUgdGhlIGNoYXJ0XG4gICAgaGFuZGxlUmV0cnkoKTtcbiAgICBcbiAgICAvLyBDbGVhbiB1cCBvbiB1bm1vdW50XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGlzTW91bnRlZFJlZi5jdXJyZW50ID0gZmFsc2U7XG4gICAgICBjbGVhbnVwQ2hhcnQoKTtcbiAgICAgIGNsZWFudXBUaW1lcnNBbmRJbnRlcnZhbHMoKTtcbiAgICB9O1xuICB9LCBbXSk7IC8vIEVtcHR5IGRlcGVuZGVuY3kgYXJyYXkgLSBydW4gb25seSBvbmNlXG5cbiAgLy8gU2V0IHVwIGRhdGEgcmVmcmVzaCBpbnRlcnZhbFxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghY2hhcnRSZWYuY3VycmVudCB8fCAhY2FuZGxlc3RpY2tTZXJpZXNSZWYuY3VycmVudCkgcmV0dXJuO1xuICAgIFxuICAgIGNvbnNvbGUubG9nKFwiU2V0dGluZyB1cCBkYXRhIHJlZnJlc2ggaW50ZXJ2YWxcIik7XG4gICAgXG4gICAgLy8gVXBkYXRlIGV2ZXJ5IDMwIHNlY29uZHNcbiAgICB1cGRhdGVJbnRlcnZhbFJlZi5jdXJyZW50ID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgaWYgKGlzTW91bnRlZFJlZi5jdXJyZW50ICYmICFpc0ZldGNoaW5nUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgZmV0Y2hDYW5kbGVEYXRhKCkuY2F0Y2goZXJyID0+IHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgaW4gaW50ZXJ2YWwgZmV0Y2g6XCIsIGVycik7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sIDMwMDAwKTtcbiAgICBcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgaWYgKHVwZGF0ZUludGVydmFsUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgY2xlYXJJbnRlcnZhbCh1cGRhdGVJbnRlcnZhbFJlZi5jdXJyZW50KTtcbiAgICAgICAgdXBkYXRlSW50ZXJ2YWxSZWYuY3VycmVudCA9IG51bGw7XG4gICAgICB9XG4gICAgfTtcbiAgfSwgW2ZldGNoQ2FuZGxlRGF0YV0pO1xuXG4gIC8vIFNldCB1cCB0cmFkZSBkYXRhIGZldGNoXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFjaGFydFJlZi5jdXJyZW50IHx8ICFjYW5kbGVzdGlja1Nlcmllc1JlZi5jdXJyZW50KSByZXR1cm47XG4gICAgXG4gICAgY29uc29sZS5sb2coXCJGZXRjaGluZyBpbml0aWFsIHRyYWRlIGRhdGFcIik7XG4gICAgZmV0Y2hUcmFkZXMoKS5jYXRjaChlcnIgPT4ge1xuICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGZldGNoaW5nIGluaXRpYWwgdHJhZGUgZGF0YTpcIiwgZXJyKTtcbiAgICB9KTtcbiAgICBcbiAgICAvLyBTZXQgdXAgaW50ZXJ2YWwgdG8gcmVmcmVzaCB0cmFkZSBkYXRhXG4gICAgY29uc3QgdHJhZGVVcGRhdGVJbnRlcnZhbCA9IHNldEludGVydmFsKCgpID0+IHtcbiAgICAgIGlmIChpc01vdW50ZWRSZWYuY3VycmVudCAmJiAhaXNGZXRjaGluZ1RyYWRlcykge1xuICAgICAgICBmZXRjaFRyYWRlcygpLmNhdGNoKGVyciA9PiB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGluIHRyYWRlIGludGVydmFsIGZldGNoOlwiLCBlcnIpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LCAzMDAwMCk7XG4gICAgXG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGNsZWFySW50ZXJ2YWwodHJhZGVVcGRhdGVJbnRlcnZhbCk7XG4gICAgfTtcbiAgfSwgW2ZldGNoVHJhZGVzXSk7XG5cbiAgLy8gVXNlIHVzZUxheW91dEVmZmVjdCB0byBjaGVjayBjb250YWluZXIgZGltZW5zaW9ucyBiZWZvcmUgbW91bnRpbmdcbiAgdXNlTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICBpZiAoY2hhcnRDb250YWluZXJSZWYuY3VycmVudCkge1xuICAgICAgY29uc3QgY29udGFpbmVyID0gY2hhcnRDb250YWluZXJSZWYuY3VycmVudDtcbiAgICAgIFxuICAgICAgLy8gRm9yY2UgY29udGFpbmVyIHRvIGJlIHZpc2libGUgYW5kIGhhdmUgZGltZW5zaW9uc1xuICAgICAgY29udGFpbmVyLnN0eWxlLndpZHRoID0gJzEwMCUnO1xuICAgICAgY29udGFpbmVyLnN0eWxlLmhlaWdodCA9ICcxMDAlJztcbiAgICAgIGNvbnRhaW5lci5zdHlsZS5taW5IZWlnaHQgPSAnNDAwcHgnO1xuICAgICAgY29udGFpbmVyLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuICAgICAgY29udGFpbmVyLnN0eWxlLnBvc2l0aW9uID0gJ3JlbGF0aXZlJztcbiAgICAgIFxuICAgICAgLy8gTG9nIGRpbWVuc2lvbnNcbiAgICAgIGNvbnNvbGUubG9nKGBJbml0aWFsIGNvbnRhaW5lciBkaW1lbnNpb25zOiAke2NvbnRhaW5lci5jbGllbnRXaWR0aH14JHtjb250YWluZXIuY2xpZW50SGVpZ2h0fWApO1xuICAgICAgXG4gICAgICAvLyBTZXQgY29udGFpbmVyIHJlYWR5IGlmIGRpbWVuc2lvbnMgYXJlIHZhbGlkXG4gICAgICBpZiAoY29udGFpbmVyLmNsaWVudFdpZHRoID4gMCAmJiBjb250YWluZXIuY2xpZW50SGVpZ2h0ID4gMCkge1xuICAgICAgICBjb250YWluZXJSZWFkeVJlZi5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEZvcmNlIGRpbWVuc2lvbnMgb25lIG1vcmUgdGltZVxuICAgICAgICBjb250YWluZXIuc3R5bGUud2lkdGggPSAnMTAwdncnO1xuICAgICAgICBjb250YWluZXIuc3R5bGUuaGVpZ2h0ID0gJzcwdmgnO1xuICAgICAgICBcbiAgICAgICAgLy8gQ2hlY2sgYWdhaW4gYWZ0ZXIgYSBtb21lbnRcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgY29uc29sZS5sb2coYERlbGF5ZWQgY29udGFpbmVyIGRpbWVuc2lvbnM6ICR7Y29udGFpbmVyLmNsaWVudFdpZHRofXgke2NvbnRhaW5lci5jbGllbnRIZWlnaHR9YCk7XG4gICAgICAgICAgY29udGFpbmVyUmVhZHlSZWYuY3VycmVudCA9IGNvbnRhaW5lci5jbGllbnRXaWR0aCA+IDAgJiYgY29udGFpbmVyLmNsaWVudEhlaWdodCA+IDA7XG4gICAgICAgIH0sIDEwMCk7XG4gICAgICB9XG4gICAgfVxuICB9LCBbXSk7XG5cbiAgLy8gSW5pdGlhbGl6ZSBjaGFydCB3aGVuIGNvbXBvbmVudCBtb3VudHNcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zb2xlLmxvZyhcIkNoYXJ0Q29tcG9uZW50IG1vdW50ZWRcIik7XG4gICAgaXNNb3VudGVkUmVmLmN1cnJlbnQgPSB0cnVlO1xuICAgIFxuICAgIC8vIFdhaXQgZm9yIG5leHQgdGljayB0byBlbnN1cmUgY29udGFpbmVyIGlzIGluIERPTVxuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgaWYgKCFjb250YWluZXJSZWFkeVJlZi5jdXJyZW50ICYmIGNoYXJ0Q29udGFpbmVyUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgLy8gQ2hlY2sgZGltZW5zaW9ucyBhZ2FpblxuICAgICAgICBjb25zdCBjb250YWluZXIgPSBjaGFydENvbnRhaW5lclJlZi5jdXJyZW50O1xuICAgICAgICBjb25zb2xlLmxvZyhgQ29udGFpbmVyIGRpbWVuc2lvbnMgYmVmb3JlIGluaXQ6ICR7Y29udGFpbmVyLmNsaWVudFdpZHRofXgke2NvbnRhaW5lci5jbGllbnRIZWlnaHR9YCk7XG4gICAgICAgIFxuICAgICAgICAvLyBGb3JjZSBtaW5pbXVtIHNpemUgaWYgbmVlZGVkXG4gICAgICAgIGlmIChjb250YWluZXIuY2xpZW50V2lkdGggPCAxMCB8fCBjb250YWluZXIuY2xpZW50SGVpZ2h0IDwgMTApIHtcbiAgICAgICAgICBjb250YWluZXIuc3R5bGUud2lkdGggPSAnMTAwJSc7XG4gICAgICAgICAgY29udGFpbmVyLnN0eWxlLmhlaWdodCA9ICc0MDBweCc7XG4gICAgICAgICAgY29udGFpbmVyLnN0eWxlLm1pbkhlaWdodCA9ICc0MDBweCc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFxuICAgICAgY29uc3Qgc3VjY2VzcyA9IGhhbmRsZVJldHJ5KCk7XG4gICAgICBcbiAgICAgIGlmIChzdWNjZXNzKSB7XG4gICAgICAgIGZldGNoQ2FuZGxlRGF0YSgpXG4gICAgICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJJbml0aWFsIGRhdGEgbG9hZGVkIHN1Y2Nlc3NmdWxseVwiKTtcbiAgICAgICAgICB9KVxuICAgICAgICAgIC5jYXRjaChlcnIgPT4ge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkZhaWxlZCB0byBsb2FkIGluaXRpYWwgZGF0YTpcIiwgZXJyKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgIC8vIFNldCB1cCBkYXRhIHJlZnJlc2ggaW50ZXJ2YWxcbiAgICAgICAgdXBkYXRlSW50ZXJ2YWxSZWYuY3VycmVudCA9IHNldEludGVydmFsKCgpID0+IHtcbiAgICAgICAgICBpZiAoaXNNb3VudGVkUmVmLmN1cnJlbnQgJiYgIWlzRmV0Y2hpbmdSZWYuY3VycmVudCkge1xuICAgICAgICAgICAgZmV0Y2hDYW5kbGVEYXRhKCkuY2F0Y2goZXJyID0+IHtcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGluIGludGVydmFsIGZldGNoOlwiLCBlcnIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCAzMDAwMCk7XG4gICAgICB9XG4gICAgfSwgMzAwKTtcbiAgICBcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgY29uc29sZS5sb2coXCJDaGFydENvbXBvbmVudCB1bm1vdW50aW5nXCIpO1xuICAgICAgaXNNb3VudGVkUmVmLmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgIGNsZWFudXBDaGFydCgpO1xuICAgICAgY2xlYW51cFRpbWVyc0FuZEludGVydmFscygpO1xuICAgIH07XG4gIH0sIFtoYW5kbGVSZXRyeSwgZmV0Y2hDYW5kbGVEYXRhLCBjbGVhbnVwQ2hhcnQsIGNsZWFudXBUaW1lcnNBbmRJbnRlcnZhbHNdKTtcblxuICAvLyBSZXR1cm4gY29tcG9uZW50IEpTWFxuICByZXR1cm4gKFxuICAgIDxkaXYgY2xhc3NOYW1lPVwiZmxleCBmbGV4LWNvbCB3LWZ1bGwgaC1mdWxsIHJlbGF0aXZlXCIgc3R5bGU9e3sgbWluSGVpZ2h0OiAnNDAwcHgnIH19PlxuICAgICAgPGRpdiBcbiAgICAgICAgcmVmPXtjaGFydENvbnRhaW5lclJlZn0gXG4gICAgICAgIGNsYXNzTmFtZT1cImZsZXgtMSB3LWZ1bGwgaC1mdWxsXCJcbiAgICAgICAgc3R5bGU9e3sgXG4gICAgICAgICAgbWluSGVpZ2h0OiAnNDAwcHgnLFxuICAgICAgICAgIHdpZHRoOiAnMTAwJScsXG4gICAgICAgICAgaGVpZ2h0OiAnMTAwJScsXG4gICAgICAgICAgcG9zaXRpb246ICdyZWxhdGl2ZScsXG4gICAgICAgICAgZGlzcGxheTogJ2Jsb2NrJ1xuICAgICAgICB9fVxuICAgICAgLz5cbiAgICAgIFxuICAgICAge2lzTG9hZGluZyAmJiAoXG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiYWJzb2x1dGUgaW5zZXQtMCBmbGV4IGl0ZW1zLWNlbnRlciBqdXN0aWZ5LWNlbnRlciBiZy1vcGFjaXR5LTc1IGJnLWdyYXktOTAwIHotMTBcIj5cbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInRleHQtd2hpdGVcIj5Mb2FkaW5nIGNoYXJ0IGRhdGEuLi48L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgICApfVxuICAgICAgXG4gICAgICB7ZXJyb3IgJiYgKFxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImFic29sdXRlIGluc2V0LTAgZmxleCBmbGV4LWNvbCBpdGVtcy1jZW50ZXIganVzdGlmeS1jZW50ZXIgYmctb3BhY2l0eS03NSBiZy1ncmF5LTkwMCB6LTEwXCI+XG4gICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJ0ZXh0LXJlZC01MDAgbWItNFwiPntlcnJvcn08L2Rpdj5cbiAgICAgICAgICA8YnV0dG9uIFxuICAgICAgICAgICAgY2xhc3NOYW1lPVwicHgtNCBweS0yIGJnLWJsdWUtNjAwIGhvdmVyOmJnLWJsdWUtNzAwIHRleHQtd2hpdGUgcm91bmRlZFwiXG4gICAgICAgICAgICBvbkNsaWNrPXtoYW5kbGVSZXRyeX1cbiAgICAgICAgICA+XG4gICAgICAgICAgICBSZXRyeVxuICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICA8L2Rpdj5cbiAgICAgICl9XG4gICAgICBcbiAgICAgIHtjdXJyZW50UHJpY2UgJiYgKFxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImFic29sdXRlIHRvcC0yIHJpZ2h0LTIgZmxleCBpdGVtcy1jZW50ZXIgc3BhY2UteC0yIHotMjBcIj5cbiAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9e2B0ZXh0LXNtIGZvbnQtbW9ubyAke3ByaWNlQ2hhbmdlUG9zaXRpdmUgPyAndGV4dC1ncmVlbi01MDAnIDogJ3RleHQtcmVkLTUwMCd9YH0+XG4gICAgICAgICAgICB7Zm9ybWF0UHJpY2UoY3VycmVudFByaWNlLCBwYWlyKX1cbiAgICAgICAgICA8L3NwYW4+XG4gICAgICAgICAge2xhc3RVcGRhdGVUaW1lICYmIChcbiAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cInRleHQteHMgdGV4dC1ncmF5LTQwMFwiPlxuICAgICAgICAgICAgICB7bGFzdFVwZGF0ZVRpbWUudG9Mb2NhbGVUaW1lU3RyaW5nKCl9XG4gICAgICAgICAgICA8L3NwYW4+XG4gICAgICAgICAgKX1cbiAgICAgICAgPC9kaXY+XG4gICAgICApfVxuICAgIDwvZGl2PlxuICApO1xufSk7ICJdLCJuYW1lcyI6WyJ1c2VFZmZlY3QiLCJ1c2VSZWYiLCJ1c2VTdGF0ZSIsInVzZUNhbGxiYWNrIiwidXNlSW1wZXJhdGl2ZUhhbmRsZSIsImZvcndhcmRSZWYiLCJ1c2VMYXlvdXRFZmZlY3QiLCJjcmVhdGVDaGFydCIsIkNyb3NzaGFpck1vZGUiLCJMaW5lU3R5bGUiLCJBY3Rpdml0eSIsIkFycm93RG93biIsIkFycm93VXAiLCJYIiwiQ2xvY2siLCJmb3JtYXRQcmljZSIsInByaWNlIiwicGFpciIsInVuZGVmaW5lZCIsInByZWNpc2lvbiIsImluY2x1ZGVzIiwidG9GaXhlZCIsInJlZiIsInRpbWVmcmFtZSIsImNoYXJ0Q29udGFpbmVyUmVmIiwiY2hhcnRSZWYiLCJjYW5kbGVzdGlja1Nlcmllc1JlZiIsInZvbHVtZVNlcmllc1JlZiIsInByaWNlTGFiZWxSZWYiLCJtYXJrZXJTZXJpZXNSZWYiLCJyZXNpemVPYnNlcnZlclJlZiIsInRpbWVyUmVmIiwidXBkYXRlSW50ZXJ2YWxSZWYiLCJpc01vdW50ZWRSZWYiLCJpc0ZldGNoaW5nUmVmIiwiY2hhcnRJbml0aWFsaXplZFJlZiIsImlzUmV0cnlpbmdSZWYiLCJjb250YWluZXJSZWFkeVJlZiIsInRyYWRlc0NvbnRhaW5lclJlZiIsImlzTG9hZGluZyIsInNldElzTG9hZGluZyIsImVycm9yIiwic2V0RXJyb3IiLCJjdXJyZW50UHJpY2UiLCJzZXRDdXJyZW50UHJpY2UiLCJwcmljZUNoYW5nZVBvc2l0aXZlIiwic2V0UHJpY2VDaGFuZ2VQb3NpdGl2ZSIsImxhc3RVcGRhdGVUaW1lIiwic2V0TGFzdFVwZGF0ZVRpbWUiLCJ0cmFkZXMiLCJzZXRUcmFkZXMiLCJpc0ZldGNoaW5nVHJhZGVzIiwic2V0SXNGZXRjaGluZ1RyYWRlcyIsImNsZWFudXBUaW1lcnNBbmRJbnRlcnZhbHMiLCJjdXJyZW50IiwiY2xlYXJUaW1lb3V0IiwiY2xlYXJJbnRlcnZhbCIsImRpc2Nvbm5lY3QiLCJjbGVhbnVwQ2hhcnQiLCJyZW1vdmUiLCJjb25zb2xlIiwibG9nIiwiZXJyIiwiZmV0Y2hDYW5kbGVEYXRhIiwiUHJvbWlzZSIsInJlc29sdmUiLCJmZXRjaCIsIkRhdGUiLCJub3ciLCJoZWFkZXJzIiwidGhlbiIsInJlc3BvbnNlIiwib2siLCJFcnJvciIsInN0YXR1cyIsImpzb24iLCJkYXRhIiwiY2FuZGxlcyIsImxlbmd0aCIsIkFycmF5IiwiaXNBcnJheSIsImNhbmRsZURhdGEiLCJmaWx0ZXIiLCJjYW5kbGUiLCJ0aW1lIiwibWFwIiwib3BlbiIsIk51bWJlciIsIm8iLCJoaWdoIiwiaCIsImxvdyIsImwiLCJjbG9zZSIsImMiLCJzZXREYXRhIiwibnVtZXJpY1ByaWNlIiwiaXNOYU4iLCJhcHBseU9wdGlvbnMiLCJ0aXRsZSIsInRpbWVTY2FsZSIsImZpdENvbnRlbnQiLCJ2aXNpYmxlUmFuZ2UiLCJnZXRWaXNpYmxlUmFuZ2UiLCJwcmljZVNjYWxlIiwiYXV0b1NjYWxlIiwibW9kZSIsInRpY2tzVmlzaWJsZSIsInNjYWxlTWFyZ2lucyIsInRvcCIsImJvdHRvbSIsImNhdGNoIiwibWVzc2FnZSIsImZpbmFsbHkiLCJmZXRjaFRyYWRlcyIsInVwZGF0ZVRyYWRlTWFya2VycyIsInRyYWRlRGF0YSIsIm1hcmtlcnMiLCJmbGF0TWFwIiwidHJhZGUiLCJ0aW1lc3RhbXAiLCJnZXRUaW1lIiwicHVzaCIsInBvc2l0aW9uIiwiZGlyZWN0aW9uIiwiY29sb3IiLCJzaGFwZSIsInRleHQiLCJlbnRyeSIsInNpemUiLCJ0b1VwcGVyQ2FzZSIsInNldE1hcmtlcnMiLCJoYW5kbGVSZXRyeSIsInNldFRpbWVvdXQiLCJjb250YWluZXIiLCJzdHlsZSIsIndpZHRoIiwiaGVpZ2h0IiwiZGlzcGxheSIsIk1hdGgiLCJtYXgiLCJjbGllbnRXaWR0aCIsImNsaWVudEhlaWdodCIsImNoYXJ0IiwibGF5b3V0IiwiYmFja2dyb3VuZCIsInRleHRDb2xvciIsImZvbnRTaXplIiwiZ3JpZCIsInZlcnRMaW5lcyIsImhvcnpMaW5lcyIsInJpZ2h0UHJpY2VTY2FsZSIsImJvcmRlckNvbG9yIiwiYm9yZGVyVmlzaWJsZSIsIm1pbmltdW1IZWlnaHQiLCJhbGlnbkxhYmVscyIsImVudGlyZVRleHRPbmx5IiwidmlzaWJsZSIsInRpbWVWaXNpYmxlIiwic2Vjb25kc1Zpc2libGUiLCJ0aWNrTWFya0Zvcm1hdHRlciIsInRpY2tNYXJrVHlwZSIsImxvY2FsZSIsImRhdGUiLCJ0b0xvY2FsZURhdGVTdHJpbmciLCJtb250aCIsImRheSIsImhvdXJzIiwiZ2V0SG91cnMiLCJ0b1N0cmluZyIsInBhZFN0YXJ0IiwibWludXRlcyIsImdldE1pbnV0ZXMiLCJjcm9zc2hhaXIiLCJOb3JtYWwiLCJ2ZXJ0TGluZSIsImxhYmVsVmlzaWJsZSIsImhvcnpMaW5lIiwid2F0ZXJtYXJrIiwiZGV0ZXJtaW5lUHJpY2VQcmVjaXNpb24iLCJzZXJpZXMiLCJhZGRDYW5kbGVzdGlja1NlcmllcyIsInVwQ29sb3IiLCJkb3duQ29sb3IiLCJ3aWNrVXBDb2xvciIsIndpY2tEb3duQ29sb3IiLCJwcmljZUZvcm1hdCIsInR5cGUiLCJtaW5Nb3ZlIiwicG93IiwibGFzdFZhbHVlVmlzaWJsZSIsInByaWNlTGluZVZpc2libGUiLCJwcmljZUxpbmVXaWR0aCIsInByaWNlTGluZUNvbG9yIiwicHJpY2VMaW5lU3R5bGUiLCJEb3R0ZWQiLCJpbnZlcnRTY2FsZSIsInZvbHVtZVNlcmllcyIsImFkZEhpc3RvZ3JhbVNlcmllcyIsInByaWNlU2NhbGVJZCIsIm1hcmtlclNlcmllcyIsImFkZExpbmVTZXJpZXMiLCJsaW5lVmlzaWJsZSIsInByaWNlTGluZSIsImNyZWF0ZVByaWNlTGluZSIsImxpbmVXaWR0aCIsImF4aXNMYWJlbFZpc2libGUiLCJoYW5kbGVSZXNpemUiLCJuZXdXaWR0aCIsIm5ld0hlaWdodCIsInJlc2l6ZSIsIlJlc2l6ZU9ic2VydmVyIiwib2JzZXJ2ZSIsIndpbmRvdyIsImFkZEV2ZW50TGlzdGVuZXIiLCJ2b2x1bWUiLCJ2b2x1bWVEYXRhIiwidmFsdWUiLCJzZXRJbnRlcnZhbCIsInRyYWRlVXBkYXRlSW50ZXJ2YWwiLCJtaW5IZWlnaHQiLCJzdWNjZXNzIiwiZGl2IiwiY2xhc3NOYW1lIiwiYnV0dG9uIiwib25DbGljayIsInNwYW4iLCJ0b0xvY2FsZVRpbWVTdHJpbmciXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./src/components/ChartComponent.js\n"));

/***/ })

});